{"version":3,"file":"partialService.js","sourceRoot":"","sources":["../../src/services/partialService.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport type { Result } from \"@/types/result\";\nimport { Ok, Err } from \"@/types/result\";\nimport type { CmuxMessage } from \"@/types/message\";\nimport type { Config } from \"@/config\";\nimport type { HistoryService } from \"./historyService\";\nimport { workspaceFileLocks } from \"@/utils/concurrency/workspaceFileLocks\";\n\n/**\n * PartialService - Manages partial message persistence for interrupted streams\n *\n * Responsibilities:\n * - Read/write/delete partial.json for all workspaces\n * - Commit partial messages to history when appropriate\n * - Encapsulate partial message lifecycle logic\n * - Synchronize file operations per workspace using MutexMap\n *\n * Separation of Concerns:\n * - PartialService owns partial.json\n * - HistoryService owns chat.jsonl\n * - StreamManager only interacts with PartialService\n * - AIService orchestrates both services\n *\n * This is a singleton service that manages partials for all workspaces.\n */\nexport class PartialService {\n  private readonly PARTIAL_FILE = \"partial.json\";\n  private readonly historyService: HistoryService;\n  // Shared file operation lock across all workspace file services\n  // This prevents deadlocks when services call each other (e.g., PartialService â†’ HistoryService)\n  private readonly fileLocks = workspaceFileLocks;\n  private readonly config: Config;\n\n  constructor(config: Config, historyService: HistoryService) {\n    this.config = config;\n    this.historyService = historyService;\n  }\n\n  private getPartialPath(workspaceId: string): string {\n    return path.join(this.config.getSessionDir(workspaceId), this.PARTIAL_FILE);\n  }\n\n  /**\n   * Read the partial message for a workspace, if it exists\n   */\n  async readPartial(workspaceId: string): Promise<CmuxMessage | null> {\n    try {\n      const partialPath = this.getPartialPath(workspaceId);\n      const data = await fs.readFile(partialPath, \"utf-8\");\n      return JSON.parse(data) as CmuxMessage;\n    } catch (error) {\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n        return null; // No partial exists\n      }\n      // Log other errors but don't fail\n      console.error(\"Error reading partial:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Write a partial message to disk (with file locking per workspace)\n   */\n  async writePartial(workspaceId: string, message: CmuxMessage): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const workspaceDir = this.config.getSessionDir(workspaceId);\n        await fs.mkdir(workspaceDir, { recursive: true });\n        const partialPath = this.getPartialPath(workspaceId);\n\n        // Ensure message has partial flag\n        const partialMessage = {\n          ...message,\n          metadata: {\n            ...message.metadata,\n            partial: true,\n          },\n        };\n\n        await fs.writeFile(partialPath, JSON.stringify(partialMessage, null, 2));\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to write partial: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Delete the partial message file for a workspace (with file locking)\n   */\n  async deletePartial(workspaceId: string): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const partialPath = this.getPartialPath(workspaceId);\n        await fs.unlink(partialPath);\n        return Ok(undefined);\n      } catch (error) {\n        if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n          return Ok(undefined); // Already deleted\n        }\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to delete partial: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Commit any existing partial message to chat.jsonl and delete partial.json.\n   * This is idempotent - if the partial has already been finalized in history,\n   * it won't be committed again (preventing double-commits).\n   * After committing (or if already finalized), partial.json is deleted.\n   *\n   * Smart commit logic:\n   * - If no message with this sequence exists in history: APPEND\n   * - If message exists but partial has more parts: UPDATE in place\n   * - Otherwise: skip commit (already finalized)\n   */\n  async commitToHistory(workspaceId: string): Promise<Result<void>> {\n    try {\n      const partial = await this.readPartial(workspaceId);\n      if (!partial) {\n        return Ok(undefined); // No partial to commit\n      }\n\n      // Don't commit errored partials to chat.jsonl\n      // Errored messages are transient failures, not committed history\n      // This prevents error accumulation when editing messages multiple times\n      if (partial.metadata?.error) {\n        return await this.deletePartial(workspaceId);\n      }\n\n      const partialSeq = partial.metadata?.historySequence;\n      if (partialSeq === undefined) {\n        return Err(\"Partial message has no historySequence\");\n      }\n\n      // Check if this partial has already been finalized in chat.jsonl\n      // A partial with MORE parts than what's in history means it's newer and should be committed\n      // (placeholder has empty parts, interrupted stream has accumulated parts)\n      const historyResult = await this.historyService.getHistory(workspaceId);\n      if (!historyResult.success) {\n        return Err(`Failed to read history: ${historyResult.error}`);\n      }\n\n      const existingMessages = historyResult.data;\n      const existingMessage = existingMessages.find(\n        (msg) => msg.metadata?.historySequence === partialSeq\n      );\n\n      const shouldCommit =\n        !existingMessage || // No message with this sequence yet\n        (partial.parts?.length ?? 0) > (existingMessage.parts?.length ?? 0); // Partial has more parts\n\n      if (shouldCommit) {\n        if (existingMessage) {\n          // Message exists (placeholder) - UPDATE it in place to avoid duplicates\n          const updateResult = await this.historyService.updateHistory(workspaceId, partial);\n          if (!updateResult.success) {\n            return updateResult;\n          }\n        } else {\n          // No message with this sequence - APPEND to history\n          const appendResult = await this.historyService.appendToHistory(workspaceId, partial);\n          if (!appendResult.success) {\n            return appendResult;\n          }\n        }\n      }\n\n      // Delete partial.json after successful commit (or if already finalized)\n      return await this.deletePartial(workspaceId);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to commit partial: ${message}`);\n    }\n  }\n}\n"]}