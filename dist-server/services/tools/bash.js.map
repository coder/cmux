{"version":3,"file":"bash.js","sourceRoot":"","sources":["../../../src/services/tools/bash.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\nimport { spawn } from \"child_process\";\nimport type { ChildProcess } from \"child_process\";\nimport { createInterface } from \"readline\";\nimport * as path from \"path\";\nimport { BASH_DEFAULT_MAX_LINES, BASH_HARD_MAX_LINES } from \"@/constants/toolLimits\";\n\nimport type { BashToolResult } from \"@/types/tools\";\nimport type { ToolConfiguration, ToolFactory } from \"@/utils/tools/tools\";\nimport { TOOL_DEFINITIONS } from \"@/utils/tools/toolDefinitions\";\n\n/**\n * Wraps a ChildProcess to make it disposable for use with `using` statements\n */\nclass DisposableProcess implements Disposable {\n  constructor(private readonly process: ChildProcess) {}\n\n  [Symbol.dispose](): void {\n    if (!this.process.killed) {\n      this.process.kill();\n    }\n  }\n\n  get child(): ChildProcess {\n    return this.process;\n  }\n}\n\n/**\n * Bash execution tool factory for AI assistant\n * Creates a bash tool that can execute commands with a configurable timeout\n * @param config Required configuration including working directory\n */\nexport const createBashTool: ToolFactory = (config: ToolConfiguration) => {\n  return tool({\n    description: TOOL_DEFINITIONS.bash.description + \"\\nRuns in \" + config.cwd + \" - no cd needed\",\n    inputSchema: TOOL_DEFINITIONS.bash.schema,\n    execute: async (\n      { script, timeout_secs, max_lines = BASH_DEFAULT_MAX_LINES, stdin },\n      { abortSignal }\n    ): Promise<BashToolResult> => {\n      const startTime = performance.now();\n      const normalizedMaxLines = Math.max(1, Math.floor(max_lines));\n      const effectiveMaxLines = Math.min(normalizedMaxLines, BASH_HARD_MAX_LINES);\n\n      // Detect redundant cd to working directory\n      // Match patterns like: \"cd /path &&\", \"cd /path;\", \"cd '/path' &&\", \"cd \\\"/path\\\" &&\"\n      const cdPattern = /^\\s*cd\\s+['\"]?([^'\";&|]+)['\"]?\\s*[;&|]/;\n      const match = cdPattern.exec(script);\n      if (match) {\n        const targetPath = match[1].trim();\n        // Normalize paths for comparison (resolve to absolute)\n        const normalizedTarget = path.resolve(config.cwd, targetPath);\n        const normalizedCwd = path.resolve(config.cwd);\n\n        if (normalizedTarget === normalizedCwd) {\n          return {\n            success: false,\n            error: `Redundant cd to working directory detected. The tool already runs in ${config.cwd} - no cd needed. Remove the 'cd ${targetPath}' prefix.`,\n            exitCode: -1,\n            wall_duration_ms: 0,\n          };\n        }\n      }\n\n      // Create the process with `using` for automatic cleanup\n      using childProcess = new DisposableProcess(\n        spawn(\"bash\", [\"-c\", script], {\n          cwd: config.cwd,\n          env: {\n            ...process.env,\n            // Prevent interactive editors from blocking bash execution\n            // This is critical for git operations like rebase/commit that try to open editors\n            GIT_EDITOR: \"true\", // Git-specific editor (highest priority)\n            GIT_SEQUENCE_EDITOR: \"true\", // For interactive rebase sequences\n            EDITOR: \"true\", // General fallback for non-git commands\n            VISUAL: \"true\", // Another common editor environment variable\n          },\n          stdio: [stdin !== undefined ? \"pipe\" : \"ignore\", \"pipe\", \"pipe\"], // stdin: pipe if provided, else ignore\n        })\n      );\n\n      // Write stdin if provided\n      if (stdin !== undefined && childProcess.child.stdin) {\n        childProcess.child.stdin.write(stdin);\n        childProcess.child.stdin.end();\n      }\n\n      // Use a promise to wait for completion\n      return await new Promise<BashToolResult>((resolve) => {\n        const lines: string[] = [];\n        let truncated = false;\n        let exitCode: number | null = null;\n        let resolved = false;\n\n        // Helper to resolve once\n        const resolveOnce = (result: BashToolResult) => {\n          if (!resolved) {\n            resolved = true;\n            clearTimeout(timeoutHandle);\n            // Clean up abort listener if present\n            if (abortSignal && abortListener) {\n              abortSignal.removeEventListener(\"abort\", abortListener);\n            }\n            resolve(result);\n          }\n        };\n\n        // Set up abort signal listener - kill process when stream is cancelled\n        let abortListener: (() => void) | null = null;\n        if (abortSignal) {\n          abortListener = () => {\n            if (!resolved) {\n              childProcess.child.kill();\n              // The close event will fire and handle finalization with abort error\n            }\n          };\n          abortSignal.addEventListener(\"abort\", abortListener);\n        }\n\n        // Set up timeout - kill process and let close event handle cleanup\n        const timeoutHandle = setTimeout(() => {\n          if (!resolved) {\n            childProcess.child.kill();\n            // The close event will fire and handle finalization with timeout error\n          }\n        }, timeout_secs * 1000);\n\n        // Set up readline for both stdout and stderr to handle line buffering\n        const stdoutReader = createInterface({ input: childProcess.child.stdout! });\n        const stderrReader = createInterface({ input: childProcess.child.stderr! });\n\n        stdoutReader.on(\"line\", (line) => {\n          if (!truncated && !resolved) {\n            lines.push(line);\n            // Check if we've exceeded the effective max_lines limit\n            if (lines.length >= effectiveMaxLines) {\n              truncated = true;\n              // Close readline interfaces before killing to ensure clean shutdown\n              stdoutReader.close();\n              stderrReader.close();\n              childProcess.child.kill();\n            }\n          }\n        });\n\n        stderrReader.on(\"line\", (line) => {\n          if (!truncated && !resolved) {\n            lines.push(line);\n            // Check if we've exceeded the effective max_lines limit\n            if (lines.length >= effectiveMaxLines) {\n              truncated = true;\n              // Close readline interfaces before killing to ensure clean shutdown\n              stdoutReader.close();\n              stderrReader.close();\n              childProcess.child.kill();\n            }\n          }\n        });\n\n        // Track when streams end\n        stdoutReader.on(\"close\", () => {\n          stdoutEnded = true;\n          tryFinalize();\n        });\n\n        stderrReader.on(\"close\", () => {\n          stderrEnded = true;\n          tryFinalize();\n        });\n\n        // Use 'exit' event instead of 'close' to handle background processes correctly.\n        // The 'close' event waits for ALL child processes (including background ones) to exit,\n        // which causes hangs when users spawn background processes like servers.\n        // The 'exit' event fires when the main bash process exits, which is what we want.\n        let stdoutEnded = false;\n        let stderrEnded = false;\n        let processExited = false;\n\n        const handleExit = (code: number | null) => {\n          processExited = true;\n          exitCode = code;\n          // Try to finalize immediately if streams have ended\n          tryFinalize();\n          // Set a grace period timer - if streams don't end within 50ms, finalize anyway\n          // This handles background processes that keep stdio open\n          setTimeout(() => {\n            if (!resolved && processExited) {\n              // Forcibly destroy streams to ensure they close\n              childProcess.child.stdout?.destroy();\n              childProcess.child.stderr?.destroy();\n              stdoutEnded = true;\n              stderrEnded = true;\n              finalize();\n            }\n          }, 50);\n        };\n\n        const tryFinalize = () => {\n          if (resolved) return;\n          // Finalize if process exited AND (both streams ended OR 100ms grace period passed)\n          if (!processExited) return;\n\n          // If we've already collected output, finalize immediately\n          // Otherwise wait a bit for streams to flush\n          if (stdoutEnded && stderrEnded) {\n            finalize();\n          }\n        };\n\n        const finalize = () => {\n          if (resolved) return;\n\n          // Round to integer to preserve tokens.\n          const wall_duration_ms = Math.round(performance.now() - startTime);\n\n          // Clean up readline interfaces if still open\n          stdoutReader.close();\n          stderrReader.close();\n\n          // Join lines and add truncation marker if needed\n          let output = lines.join(\"\\n\");\n          if (truncated && output.length > 0) {\n            output += \" [TRUNCATED]\";\n          }\n\n          // Check if this was aborted (stream cancelled)\n          const wasAborted = abortSignal?.aborted ?? false;\n          // Check if this was a timeout (process killed and no natural exit code)\n          const timedOut = !wasAborted && wall_duration_ms >= timeout_secs * 1000 - 10; // 10ms tolerance\n\n          if (wasAborted) {\n            resolveOnce({\n              success: false,\n              error: \"Command aborted due to stream cancellation\",\n              exitCode: -2,\n              wall_duration_ms,\n              truncated,\n            });\n          } else if (timedOut) {\n            resolveOnce({\n              success: false,\n              error: `Command timed out after ${timeout_secs} seconds`,\n              exitCode: -1,\n              wall_duration_ms,\n              truncated,\n            });\n          } else if (exitCode === 0 || exitCode === null) {\n            resolveOnce({\n              success: true,\n              output,\n              exitCode: 0,\n              wall_duration_ms,\n              ...(truncated && { truncated: true }),\n            });\n          } else {\n            resolveOnce({\n              success: false,\n              output,\n              exitCode,\n              error: `Command exited with code ${exitCode}`,\n              wall_duration_ms,\n              truncated,\n            });\n          }\n        };\n\n        // Listen to exit event (fires when bash exits, before streams close)\n        childProcess.child.on(\"exit\", handleExit);\n\n        childProcess.child.on(\"error\", (err: Error) => {\n          if (resolved) return;\n          const wall_duration_ms = performance.now() - startTime;\n          resolveOnce({\n            success: false,\n            error: `Failed to execute command: ${err.message}`,\n            exitCode: -1,\n            wall_duration_ms,\n          });\n        });\n      });\n    },\n  });\n};\n"]}