{"version":3,"file":"file_edit_replace.js","sourceRoot":"","sources":["../../../src/services/tools/file_edit_replace.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport writeFileAtomic from \"write-file-atomic\";\nimport type { FileEditReplaceToolResult } from \"@/types/tools\";\nimport type { ToolConfiguration, ToolFactory } from \"@/utils/tools/tools\";\nimport { TOOL_DEFINITIONS } from \"@/utils/tools/toolDefinitions\";\nimport { leaseFromStat, generateDiff, validatePathInCwd } from \"./fileCommon\";\n\n/**\n * File edit replace tool factory for AI assistant\n * Creates a tool that allows the AI to apply multiple edits to a file\n * @param config Required configuration including working directory\n */\nexport const createFileEditReplaceTool: ToolFactory = (config: ToolConfiguration) => {\n  return tool({\n    description: TOOL_DEFINITIONS.file_edit_replace.description,\n    inputSchema: TOOL_DEFINITIONS.file_edit_replace.schema,\n    execute: async (\n      { file_path, edits, lease },\n      { abortSignal: _abortSignal }\n    ): Promise<FileEditReplaceToolResult> => {\n      // Note: abortSignal available but not used - file operations are fast and complete quickly\n      try {\n        // Validate that the path is within the working directory\n        const pathValidation = validatePathInCwd(file_path, config.cwd);\n        if (pathValidation) {\n          return {\n            success: false,\n            error: pathValidation.error,\n          };\n        }\n\n        // Resolve path (but expect absolute paths)\n        const resolvedPath = path.isAbsolute(file_path)\n          ? file_path\n          : path.resolve(config.cwd, file_path);\n\n        // Check if file exists\n        const stats = await fs.stat(resolvedPath);\n        if (!stats.isFile()) {\n          return {\n            success: false,\n            error: `Path exists but is not a file: ${resolvedPath}`,\n          };\n        }\n\n        // Validate lease to prevent editing stale file state\n        const currentLease = leaseFromStat(stats);\n        if (currentLease !== lease) {\n          return {\n            success: false,\n            error: `WRITE DENIED: File lease mismatch. The file has been modified since it was read. Please read the file again.`,\n          };\n        }\n\n        // Read file content\n        const originalContent = await fs.readFile(resolvedPath, { encoding: \"utf-8\" });\n        let content = originalContent;\n\n        // Apply each edit sequentially\n        // THE KEY INSIGHT: MultiEdit is a state machine where each edit operates on the\n        // output of the previous edit, not the original file.\n        //\n        // For example, if the file contains \"foo bar baz\":\n        //   Edit 1: \"foo\" -> \"FOO\" transforms content to \"FOO bar baz\"\n        //   Edit 2: \"bar\" -> \"BAR\" operates on \"FOO bar baz\", resulting in \"FOO BAR baz\"\n        //   Edit 3: \"foo\" -> \"qux\" would FAIL because \"foo\" no longer exists in the current state\n        //\n        // If ANY edit fails, the entire operation is rolled back - the file remains unchanged\n        // because we only write to disk after all edits succeed.\n        let editsApplied = 0;\n        for (let i = 0; i < edits.length; i++) {\n          const edit = edits[i];\n          const replaceCount = edit.replace_count ?? 1; // Default to 1\n\n          // Validate old_string exists in content\n          if (!content.includes(edit.old_string)) {\n            return {\n              success: false,\n              error: `Edit ${i + 1}: old_string not found in file. The text to replace must exist exactly as written in the file.`,\n            };\n          }\n\n          // Count occurrences\n          const parts = content.split(edit.old_string);\n          const occurrences = parts.length - 1;\n\n          // Check for uniqueness if replace_count is 1\n          if (replaceCount === 1 && occurrences > 1) {\n            return {\n              success: false,\n              error: `Edit ${i + 1}: old_string appears ${occurrences} times in the file. Either expand the context to make it unique or set replace_count to ${occurrences} or -1.`,\n            };\n          }\n\n          // Validate replace_count doesn't exceed occurrences (unless -1)\n          if (replaceCount > occurrences && replaceCount !== -1) {\n            return {\n              success: false,\n              error: `Edit ${i + 1}: replace_count is ${replaceCount} but old_string only appears ${occurrences} time(s) in the file.`,\n            };\n          }\n\n          // Apply the edit\n          if (replaceCount === -1) {\n            // Replace all occurrences\n            content = parts.join(edit.new_string);\n            editsApplied += occurrences;\n          } else {\n            // Replace the specified number of occurrences\n            let replacedCount = 0;\n            let currentContent = content;\n\n            for (let j = 0; j < replaceCount; j++) {\n              const index = currentContent.indexOf(edit.old_string);\n              if (index !== -1) {\n                currentContent =\n                  currentContent.substring(0, index) +\n                  edit.new_string +\n                  currentContent.substring(index + edit.old_string.length);\n                replacedCount++;\n              } else {\n                break;\n              }\n            }\n\n            content = currentContent;\n            editsApplied += replacedCount;\n          }\n        }\n\n        // Write the modified content back to file atomically\n        await writeFileAtomic(resolvedPath, content, { encoding: \"utf-8\" });\n\n        // Get new file stats and compute new lease\n        const newStats = await fs.stat(resolvedPath);\n        const newLease = leaseFromStat(newStats);\n\n        // Generate diff\n        const diff = generateDiff(resolvedPath, originalContent, content);\n\n        return {\n          success: true,\n          edits_applied: editsApplied,\n          lease: newLease,\n          diff,\n        };\n      } catch (error) {\n        // Handle specific errors\n        if (error && typeof error === \"object\" && \"code\" in error) {\n          if (error.code === \"ENOENT\") {\n            return {\n              success: false,\n              error: `File not found: ${file_path}`,\n            };\n          } else if (error.code === \"EACCES\") {\n            return {\n              success: false,\n              error: `Permission denied: ${file_path}`,\n            };\n          }\n        }\n\n        // Generic error\n        const message = error instanceof Error ? error.message : String(error);\n        return {\n          success: false,\n          error: `Failed to edit file: ${message}`,\n        };\n      }\n    },\n  });\n};\n"]}