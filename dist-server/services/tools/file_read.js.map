{"version":3,"file":"file_read.js","sourceRoot":"","sources":["../../../src/services/tools/file_read.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport * as readline from \"readline\";\nimport type { FileReadToolResult } from \"@/types/tools\";\nimport type { ToolConfiguration, ToolFactory } from \"@/utils/tools/tools\";\nimport { TOOL_DEFINITIONS } from \"@/utils/tools/toolDefinitions\";\nimport { leaseFromStat, validatePathInCwd } from \"./fileCommon\";\n\n/**\n * File read tool factory for AI assistant\n * Creates a tool that allows the AI to read file contents from the file system\n * @param config Required configuration including working directory\n */\nexport const createFileReadTool: ToolFactory = (config: ToolConfiguration) => {\n  return tool({\n    description: TOOL_DEFINITIONS.file_read.description,\n    inputSchema: TOOL_DEFINITIONS.file_read.schema,\n    execute: async (\n      { filePath, offset, limit },\n      { abortSignal: _abortSignal }\n    ): Promise<FileReadToolResult> => {\n      // Note: abortSignal available but not used - file reads are fast and complete quickly\n      try {\n        // Validate that the path is within the working directory\n        const pathValidation = validatePathInCwd(filePath, config.cwd);\n        if (pathValidation) {\n          return {\n            success: false,\n            error: pathValidation.error,\n          };\n        }\n\n        // Resolve relative paths from configured working directory\n        const resolvedPath = path.isAbsolute(filePath)\n          ? filePath\n          : path.resolve(config.cwd, filePath);\n\n        // Check if file exists\n        const stats = await fs.stat(resolvedPath);\n        if (!stats.isFile()) {\n          return {\n            success: false,\n            error: `Path exists but is not a file: ${resolvedPath}`,\n          };\n        }\n\n        // Compute lease for this file state\n        const lease = leaseFromStat(stats);\n\n        const startLineNumber = offset ?? 1;\n\n        // Validate offset\n        if (offset !== undefined && offset < 1) {\n          return {\n            success: false,\n            error: `Offset must be positive (got ${offset})`,\n          };\n        }\n\n        // Open file with using for automatic cleanup\n        await using fileHandle = await fs.open(resolvedPath, \"r\");\n\n        // Create readline interface for line-by-line reading\n        const rl = readline.createInterface({\n          input: fileHandle.createReadStream({ encoding: \"utf-8\" }),\n          crlfDelay: Infinity,\n        });\n\n        const numberedLines: string[] = [];\n        let currentLineNumber = 1;\n        let totalLinesRead = 0;\n        let totalBytesAccumulated = 0;\n        const MAX_LINE_BYTES = 1024;\n        const MAX_LINES = 1000;\n        const MAX_TOTAL_BYTES = 16 * 1024; // 16KB\n\n        // Iterate through file line by line\n        for await (const line of rl) {\n          // Skip lines before offset\n          if (currentLineNumber < startLineNumber) {\n            currentLineNumber++;\n            continue;\n          }\n\n          // Truncate line if it exceeds max bytes\n          let processedLine = line;\n          const lineBytes = Buffer.byteLength(line, \"utf-8\");\n          if (lineBytes > MAX_LINE_BYTES) {\n            // Truncate to MAX_LINE_BYTES\n            processedLine = Buffer.from(line, \"utf-8\")\n              .subarray(0, MAX_LINE_BYTES)\n              .toString(\"utf-8\");\n            processedLine += \"... [truncated]\";\n          }\n\n          // Format line with number prefix\n          const numberedLine = `${currentLineNumber}\\t${processedLine}`;\n          const numberedLineBytes = Buffer.byteLength(numberedLine, \"utf-8\");\n\n          // Check if adding this line would exceed byte limit\n          if (totalBytesAccumulated + numberedLineBytes > MAX_TOTAL_BYTES) {\n            return {\n              success: false,\n              error: `Output would exceed ${MAX_TOTAL_BYTES} bytes. Please read less at a time using offset and limit parameters.`,\n            };\n          }\n\n          numberedLines.push(numberedLine);\n          totalBytesAccumulated += numberedLineBytes + 1; // +1 for newline\n          totalLinesRead++;\n          currentLineNumber++;\n\n          // Check if we've exceeded max lines\n          if (totalLinesRead > MAX_LINES) {\n            return {\n              success: false,\n              error: `Output would exceed ${MAX_LINES} lines. Please read less at a time using offset and limit parameters.`,\n            };\n          }\n\n          // Stop if we've collected enough lines\n          if (limit !== undefined && totalLinesRead >= limit) {\n            break;\n          }\n        }\n\n        // Check if offset was beyond file length\n        if (offset !== undefined && numberedLines.length === 0) {\n          return {\n            success: false,\n            error: `Offset ${offset} is beyond file length`,\n          };\n        }\n\n        // Join lines with newlines\n        const content = numberedLines.join(\"\\n\");\n\n        // Return file info and content\n        // IMPORTANT: lease must be last in the return object so it remains fresh in the LLM's context\n        // when it's reading this tool result. The LLM needs the lease value to perform subsequent edits.\n        return {\n          success: true,\n          file_size: stats.size,\n          modifiedTime: stats.mtime.toISOString(),\n          lines_read: numberedLines.length,\n          content,\n          lease, // Must be last - see comment above\n        };\n      } catch (error) {\n        // Handle specific errors\n        if (error && typeof error === \"object\" && \"code\" in error) {\n          if (error.code === \"ENOENT\") {\n            return {\n              success: false,\n              error: `File not found: ${filePath}`,\n            };\n          } else if (error.code === \"EACCES\") {\n            return {\n              success: false,\n              error: `Permission denied: ${filePath}`,\n            };\n          }\n        }\n\n        // Generic error\n        const message = error instanceof Error ? error.message : String(error);\n        return {\n          success: false,\n          error: `Failed to read file: ${message}`,\n        };\n      }\n    },\n  });\n};\n"]}