{"version":3,"file":"file_edit_insert.js","sourceRoot":"","sources":["../../../src/services/tools/file_edit_insert.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport writeFileAtomic from \"write-file-atomic\";\nimport type { FileEditInsertToolResult } from \"@/types/tools\";\nimport type { ToolConfiguration, ToolFactory } from \"@/utils/tools/tools\";\nimport { TOOL_DEFINITIONS } from \"@/utils/tools/toolDefinitions\";\nimport { leaseFromStat, generateDiff, validatePathInCwd } from \"./fileCommon\";\n\n/**\n * File edit insert tool factory for AI assistant\n * Creates a tool that allows the AI to insert content at a specific line position\n * @param config Required configuration including working directory\n */\nexport const createFileEditInsertTool: ToolFactory = (config: ToolConfiguration) => {\n  return tool({\n    description: TOOL_DEFINITIONS.file_edit_insert.description,\n    inputSchema: TOOL_DEFINITIONS.file_edit_insert.schema,\n    execute: async ({\n      file_path,\n      line_offset,\n      content,\n      lease,\n    }): Promise<FileEditInsertToolResult> => {\n      try {\n        // Validate that the path is within the working directory\n        const pathValidation = validatePathInCwd(file_path, config.cwd);\n        if (pathValidation) {\n          return {\n            success: false,\n            error: pathValidation.error,\n          };\n        }\n\n        // Resolve path (but expect absolute paths)\n        const resolvedPath = path.isAbsolute(file_path)\n          ? file_path\n          : path.resolve(config.cwd, file_path);\n\n        // Check if file exists\n        const stats = await fs.stat(resolvedPath);\n        if (!stats.isFile()) {\n          return {\n            success: false,\n            error: `Path exists but is not a file: ${resolvedPath}`,\n          };\n        }\n\n        // Validate lease to prevent editing stale file state\n        const currentLease = leaseFromStat(stats);\n        if (currentLease !== lease) {\n          return {\n            success: false,\n            error: `WRITE DENIED: File lease mismatch. The file has been modified since it was read. Please read the file again.`,\n          };\n        }\n\n        // Read file content\n        const originalContent = await fs.readFile(resolvedPath, { encoding: \"utf-8\" });\n        const lines = originalContent.split(\"\\n\");\n\n        // Validate line_offset\n        if (line_offset < 0) {\n          return {\n            success: false,\n            error: `line_offset must be non-negative (got ${line_offset})`,\n          };\n        }\n\n        if (line_offset > lines.length) {\n          return {\n            success: false,\n            error: `line_offset ${line_offset} is beyond file length (${lines.length} lines)`,\n          };\n        }\n\n        // Insert content at specified line\n        // line_offset = 0: insert at top (before line 1)\n        // line_offset = N: insert after line N\n        const newLines = [...lines.slice(0, line_offset), content, ...lines.slice(line_offset)];\n        const newContent = newLines.join(\"\\n\");\n\n        // Write the modified content back to file atomically\n        await writeFileAtomic(resolvedPath, newContent, { encoding: \"utf-8\" });\n\n        // Get new file stats and compute new lease\n        const newStats = await fs.stat(resolvedPath);\n        const newLease = leaseFromStat(newStats);\n\n        // Generate diff\n        const diff = generateDiff(resolvedPath, originalContent, newContent);\n\n        return {\n          success: true,\n          lease: newLease,\n          diff,\n        };\n      } catch (error) {\n        // Handle specific errors\n        if (error && typeof error === \"object\" && \"code\" in error) {\n          if (error.code === \"ENOENT\") {\n            return {\n              success: false,\n              error: `File not found: ${file_path}`,\n            };\n          } else if (error.code === \"EACCES\") {\n            return {\n              success: false,\n              error: `Permission denied: ${file_path}`,\n            };\n          }\n        }\n\n        // Generic error\n        const message = error instanceof Error ? error.message : String(error);\n        return {\n          success: false,\n          error: `Failed to insert content: ${message}`,\n        };\n      }\n    },\n  });\n};\n"]}