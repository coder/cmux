{"version":3,"file":"historyService.js","sourceRoot":"","sources":["../../src/services/historyService.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport type { Result } from \"@/types/result\";\nimport { Ok, Err } from \"@/types/result\";\nimport type { CmuxMessage } from \"@/types/message\";\nimport type { Config } from \"@/config\";\nimport { workspaceFileLocks } from \"@/utils/concurrency/workspaceFileLocks\";\nimport { log } from \"./log\";\nimport { getTokenizerForModel } from \"@/utils/tokens/tokenizer\";\n\n/**\n * HistoryService - Manages chat history persistence and sequence numbering\n *\n * Responsibilities:\n * - Read/write chat history to disk (JSONL format)\n * - Assign sequence numbers to messages (single source of truth)\n * - Track next sequence number per workspace\n */\nexport class HistoryService {\n  private readonly CHAT_FILE = \"chat.jsonl\";\n  // Track next sequence number per workspace in memory\n  private sequenceCounters = new Map<string, number>();\n  // Shared file operation lock across all workspace file services\n  // This prevents deadlocks when services call each other (e.g., PartialService â†’ HistoryService)\n  private readonly fileLocks = workspaceFileLocks;\n  private readonly config: Config;\n\n  constructor(config: Config) {\n    this.config = config;\n  }\n\n  private getChatHistoryPath(workspaceId: string): string {\n    return path.join(this.config.getSessionDir(workspaceId), this.CHAT_FILE);\n  }\n\n  /**\n   * Read raw messages from chat.jsonl (does not include partial.json)\n   * Returns empty array if file doesn't exist\n   * Skips malformed JSON lines to prevent data loss from corruption\n   */\n  private async readChatHistory(workspaceId: string): Promise<CmuxMessage[]> {\n    try {\n      const chatHistoryPath = this.getChatHistoryPath(workspaceId);\n      const data = await fs.readFile(chatHistoryPath, \"utf-8\");\n      const lines = data.split(\"\\n\").filter((line) => line.trim());\n      const messages: CmuxMessage[] = [];\n\n      for (let i = 0; i < lines.length; i++) {\n        try {\n          const message = JSON.parse(lines[i]) as CmuxMessage;\n          messages.push(message);\n        } catch (parseError) {\n          // Skip malformed lines but log error for debugging\n          console.error(\n            `[HistoryService] Skipping malformed JSON at line ${i + 1} in ${workspaceId}/chat.jsonl:`,\n            parseError instanceof Error ? parseError.message : String(parseError),\n            \"\\nLine content:\",\n            lines[i].substring(0, 100) + (lines[i].length > 100 ? \"...\" : \"\")\n          );\n        }\n      }\n\n      return messages;\n    } catch (error) {\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n        return []; // No history yet\n      }\n      throw error; // Re-throw non-ENOENT errors\n    }\n  }\n\n  async getHistory(workspaceId: string): Promise<Result<CmuxMessage[]>> {\n    try {\n      // Read chat history from disk\n      // Note: partial.json is NOT merged here - it's managed by PartialService\n      const messages = await this.readChatHistory(workspaceId);\n      return Ok(messages);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to read history: ${message}`);\n    }\n  }\n\n  /**\n   * Get or initialize the next history sequence number for a workspace\n   */\n  private async getNextHistorySequence(workspaceId: string): Promise<number> {\n    // Check if we already have it in memory\n    if (this.sequenceCounters.has(workspaceId)) {\n      return this.sequenceCounters.get(workspaceId)!;\n    }\n\n    // Initialize from history\n    const historyResult = await this.getHistory(workspaceId);\n    if (historyResult.success) {\n      const messages = historyResult.data;\n      // Find max history sequence number\n      let maxSeqNum = -1;\n      for (const msg of messages) {\n        const seqNum = msg.metadata?.historySequence;\n        if (seqNum !== undefined && seqNum > maxSeqNum) {\n          maxSeqNum = seqNum;\n        }\n      }\n      const nextSeqNum = maxSeqNum + 1;\n      this.sequenceCounters.set(workspaceId, nextSeqNum);\n      return nextSeqNum;\n    }\n\n    // No history yet, start from 0\n    this.sequenceCounters.set(workspaceId, 0);\n    return 0;\n  }\n\n  /**\n   * Internal helper for appending to history without acquiring lock\n   * Used by both appendToHistory and commitPartial to avoid deadlock\n   */\n  private async _appendToHistoryUnlocked(\n    workspaceId: string,\n    message: CmuxMessage\n  ): Promise<Result<void>> {\n    try {\n      const workspaceDir = this.config.getSessionDir(workspaceId);\n      await fs.mkdir(workspaceDir, { recursive: true });\n      const historyPath = this.getChatHistoryPath(workspaceId);\n\n      // DEBUG: Log message append with caller stack trace\n      const stack = new Error().stack?.split(\"\\n\").slice(2, 6).join(\"\\n\") ?? \"no stack\";\n      log.debug(\n        `[HISTORY APPEND] workspaceId=${workspaceId} role=${message.role} id=${message.id}`\n      );\n      log.debug(`[HISTORY APPEND] Call stack:\\n${stack}`);\n\n      // Ensure message has a history sequence number\n      if (!message.metadata) {\n        // Create metadata with history sequence\n        const nextSeqNum = await this.getNextHistorySequence(workspaceId);\n        message.metadata = {\n          historySequence: nextSeqNum,\n        };\n        this.sequenceCounters.set(workspaceId, nextSeqNum + 1);\n      } else {\n        // Message already has metadata, but may need historySequence assigned\n        const existingSeqNum = message.metadata.historySequence;\n        if (existingSeqNum !== undefined) {\n          // Already has history sequence, update counter if needed\n          const currentCounter = this.sequenceCounters.get(workspaceId) ?? 0;\n          if (existingSeqNum >= currentCounter) {\n            this.sequenceCounters.set(workspaceId, existingSeqNum + 1);\n          }\n        } else {\n          // Has metadata but no historySequence, assign one\n          const nextSeqNum = await this.getNextHistorySequence(workspaceId);\n          message.metadata = {\n            ...message.metadata,\n            historySequence: nextSeqNum,\n          };\n          this.sequenceCounters.set(workspaceId, nextSeqNum + 1);\n        }\n      }\n\n      // Store the message with workspace context\n      const historyEntry = {\n        ...message,\n        workspaceId,\n      };\n\n      // DEBUG: Log assigned sequence number\n      log.debug(\n        `[HISTORY APPEND] Assigned historySequence=${message.metadata.historySequence} role=${message.role}`\n      );\n\n      await fs.appendFile(historyPath, JSON.stringify(historyEntry) + \"\\n\");\n      return Ok(undefined);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to append to history: ${message}`);\n    }\n  }\n\n  async appendToHistory(workspaceId: string, message: CmuxMessage): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      return this._appendToHistoryUnlocked(workspaceId, message);\n    });\n  }\n\n  /**\n   * Update an existing message in history by historySequence\n   * Reads entire history, replaces the matching message, and rewrites the file\n   */\n  async updateHistory(workspaceId: string, message: CmuxMessage): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const historyPath = this.getChatHistoryPath(workspaceId);\n\n        // Read all messages\n        const historyResult = await this.getHistory(workspaceId);\n        if (!historyResult.success) {\n          return historyResult; // Return the error\n        }\n\n        const messages = historyResult.data;\n        const targetSequence = message.metadata?.historySequence;\n\n        if (targetSequence === undefined) {\n          return Err(\"Cannot update message without historySequence\");\n        }\n\n        // Find and replace the message with matching historySequence\n        let found = false;\n        for (let i = 0; i < messages.length; i++) {\n          if (messages[i].metadata?.historySequence === targetSequence) {\n            // Preserve the historySequence, update everything else\n            messages[i] = {\n              ...message,\n              metadata: {\n                ...message.metadata,\n                historySequence: targetSequence,\n              },\n            };\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          return Err(`No message found with historySequence ${targetSequence}`);\n        }\n\n        // Rewrite entire file\n        const historyEntries = messages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\n          .join(\"\");\n\n        await fs.writeFile(historyPath, historyEntries);\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to update history: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Truncate history after a specific message ID\n   * Removes the message with the given ID and all subsequent messages\n   */\n  async truncateAfterMessage(workspaceId: string, messageId: string): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const historyResult = await this.getHistory(workspaceId);\n        if (!historyResult.success) {\n          return historyResult;\n        }\n\n        const messages = historyResult.data;\n        const messageIndex = messages.findIndex((msg) => msg.id === messageId);\n\n        if (messageIndex === -1) {\n          return Err(`Message with ID ${messageId} not found in history`);\n        }\n\n        // Keep only messages before the target message\n        const truncatedMessages = messages.slice(0, messageIndex);\n\n        // Rewrite the history file with truncated messages\n        const historyPath = this.getChatHistoryPath(workspaceId);\n        const historyEntries = truncatedMessages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\n          .join(\"\");\n\n        await fs.writeFile(historyPath, historyEntries);\n\n        // Update sequence counter to continue from where we truncated\n        if (truncatedMessages.length > 0) {\n          const lastMsg = truncatedMessages[truncatedMessages.length - 1];\n          const lastSeq = lastMsg.metadata?.historySequence ?? 0;\n          this.sequenceCounters.set(workspaceId, lastSeq + 1);\n        } else {\n          this.sequenceCounters.set(workspaceId, 0);\n        }\n\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to truncate history: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Truncate history by removing approximately the given percentage of tokens from the beginning\n   * @param workspaceId The workspace ID\n   * @param percentage Percentage to truncate (0.0 to 1.0). 1.0 = delete all\n   * @returns Result containing array of deleted historySequence numbers\n   */\n  async truncateHistory(\n    workspaceId: string,\n    percentage: number\n  ): Promise<Result<number[], string>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const historyPath = this.getChatHistoryPath(workspaceId);\n\n        // Fast path: 100% truncation = delete entire file\n        if (percentage >= 1.0) {\n          const historyResult = await this.getHistory(workspaceId);\n          const deletedSequences = historyResult.success\n            ? historyResult.data\n                .map((msg) => msg.metadata?.historySequence ?? -1)\n                .filter((s) => s >= 0)\n            : [];\n\n          try {\n            await fs.unlink(historyPath);\n          } catch (error) {\n            // Ignore ENOENT - file already deleted\n            if (\n              !(error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\")\n            ) {\n              throw error;\n            }\n          }\n\n          // Reset sequence counter when clearing history\n          this.sequenceCounters.set(workspaceId, 0);\n          return Ok(deletedSequences);\n        }\n\n        // Read all messages\n        const historyResult = await this.getHistory(workspaceId);\n        if (!historyResult.success) {\n          return Err(historyResult.error);\n        }\n\n        const messages = historyResult.data;\n        if (messages.length === 0) {\n          return Ok([]); // Nothing to truncate\n        }\n\n        // Get tokenizer for counting (use a default model)\n        const tokenizer = getTokenizerForModel(\"anthropic:claude-sonnet-4-5\");\n\n        // Count tokens for each message\n        // We stringify the entire message for simplicity - only relative weights matter\n        const messageTokens: Array<{ message: CmuxMessage; tokens: number }> = messages.map(\n          (msg) => {\n            const tokens = tokenizer.countTokens(JSON.stringify(msg));\n            return { message: msg, tokens };\n          }\n        );\n\n        // Calculate total tokens and target to remove\n        const totalTokens = messageTokens.reduce((sum, mt) => sum + mt.tokens, 0);\n        const tokensToRemove = Math.floor(totalTokens * percentage);\n\n        // Remove messages from beginning until we've removed enough tokens\n        let tokensRemoved = 0;\n        let removeCount = 0;\n        for (const mt of messageTokens) {\n          if (tokensRemoved >= tokensToRemove) {\n            break;\n          }\n          tokensRemoved += mt.tokens;\n          removeCount++;\n        }\n\n        // If we're removing all messages, use fast path\n        if (removeCount >= messages.length) {\n          try {\n            await fs.unlink(historyPath);\n          } catch (error) {\n            // Ignore ENOENT\n            if (\n              !(error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\")\n            ) {\n              throw error;\n            }\n          }\n          this.sequenceCounters.set(workspaceId, 0);\n          const deletedSequences = messages\n            .map((msg) => msg.metadata?.historySequence ?? -1)\n            .filter((s) => s >= 0);\n          return Ok(deletedSequences);\n        }\n\n        // Keep messages after removeCount\n        const remainingMessages = messages.slice(removeCount);\n        const deletedMessages = messages.slice(0, removeCount);\n        const deletedSequences = deletedMessages\n          .map((msg) => msg.metadata?.historySequence ?? -1)\n          .filter((s) => s >= 0);\n\n        // Rewrite the history file with remaining messages\n        const historyEntries = remainingMessages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\n          .join(\"\");\n\n        await fs.writeFile(historyPath, historyEntries);\n\n        // Update sequence counter to continue from where we are\n        if (remainingMessages.length > 0) {\n          const lastMsg = remainingMessages[remainingMessages.length - 1];\n          const lastSeq = lastMsg.metadata?.historySequence ?? 0;\n          this.sequenceCounters.set(workspaceId, lastSeq + 1);\n        } else {\n          this.sequenceCounters.set(workspaceId, 0);\n        }\n\n        return Ok(deletedSequences);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to truncate history: ${message}`);\n      }\n    });\n  }\n\n  async clearHistory(workspaceId: string): Promise<Result<void>> {\n    const result = await this.truncateHistory(workspaceId, 1.0);\n    if (!result.success) {\n      return Err(result.error);\n    }\n    return Ok(undefined);\n  }\n\n  /**\n   * Migrate all messages in chat.jsonl to use a new workspace ID\n   * This is used during workspace rename to update the workspaceId field in all historical messages\n   * IMPORTANT: Should be called AFTER the session directory has been renamed\n   */\n  async migrateWorkspaceId(oldWorkspaceId: string, newWorkspaceId: string): Promise<Result<void>> {\n    return this.fileLocks.withLock(newWorkspaceId, async () => {\n      try {\n        // Read messages from the NEW workspace location (directory was already renamed)\n        const historyResult = await this.getHistory(newWorkspaceId);\n        if (!historyResult.success) {\n          return historyResult;\n        }\n\n        const messages = historyResult.data;\n        if (messages.length === 0) {\n          // No messages to migrate, just transfer sequence counter\n          const oldCounter = this.sequenceCounters.get(oldWorkspaceId) ?? 0;\n          this.sequenceCounters.set(newWorkspaceId, oldCounter);\n          this.sequenceCounters.delete(oldWorkspaceId);\n          return Ok(undefined);\n        }\n\n        // Rewrite all messages with new workspace ID\n        const newHistoryPath = this.getChatHistoryPath(newWorkspaceId);\n        const historyEntries = messages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId: newWorkspaceId }) + \"\\n\")\n          .join(\"\");\n\n        await fs.writeFile(newHistoryPath, historyEntries);\n\n        // Transfer sequence counter to new workspace ID\n        const oldCounter = this.sequenceCounters.get(oldWorkspaceId) ?? 0;\n        this.sequenceCounters.set(newWorkspaceId, oldCounter);\n        this.sequenceCounters.delete(oldWorkspaceId);\n\n        log.debug(\n          `Migrated ${messages.length} messages from ${oldWorkspaceId} to ${newWorkspaceId}`\n        );\n\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to migrate workspace ID: ${message}`);\n      }\n    });\n  }\n}\n"]}