{"version":3,"file":"streamManager.js","sourceRoot":"","sources":["../../src/services/streamManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from \"events\";\nimport { randomUUID } from \"crypto\";\nimport {\n  streamText,\n  stepCountIs,\n  type ModelMessage,\n  type LanguageModel,\n  type Tool,\n  LoadAPIKeyError,\n  APICallError,\n  RetryError,\n} from \"ai\";\nimport type { Result } from \"@/types/result\";\nimport { Ok, Err } from \"@/types/result\";\nimport { log } from \"./log\";\nimport type {\n  StreamStartEvent,\n  StreamDeltaEvent,\n  StreamEndEvent,\n  ErrorEvent,\n  ToolCallStartEvent,\n  ToolCallEndEvent,\n  CompletedMessagePart,\n} from \"@/types/stream\";\nimport type { SendMessageError, StreamErrorType } from \"@/types/errors\";\nimport type { CmuxMetadata, CmuxMessage } from \"@/types/message\";\nimport type { PartialService } from \"./partialService\";\nimport type { HistoryService } from \"./historyService\";\nimport { AsyncMutex } from \"@/utils/concurrency/asyncMutex\";\nimport type { ToolPolicy } from \"@/utils/tools/toolPolicy\";\n\n// Type definitions for stream parts with extended properties\ninterface ReasoningDeltaPart {\n  type: \"reasoning-delta\";\n  text?: string;\n}\n\n// Branded types for compile-time safety\ntype WorkspaceId = string & { __brand: \"WorkspaceId\" };\ntype StreamToken = string & { __brand: \"StreamToken\" };\n\n// Stream state enum for exhaustive checking\nenum StreamState {\n  IDLE = \"idle\",\n  STARTING = \"starting\",\n  STREAMING = \"streaming\",\n  STOPPING = \"stopping\",\n  ERROR = \"error\",\n}\n\n/**\n * Strip encryptedContent from web search results to reduce token usage.\n * The encrypted page content can be massive (4000+ chars per result) and isn't\n * needed for model context. Keep URL, title, and pageAge for reference.\n */\nfunction stripEncryptedContent(output: unknown): unknown {\n  // Check if output is JSON with a value array (web search results)\n  if (\n    typeof output === \"object\" &&\n    output !== null &&\n    \"type\" in output &&\n    output.type === \"json\" &&\n    \"value\" in output &&\n    Array.isArray(output.value)\n  ) {\n    // Strip encryptedContent from each search result\n    const strippedValue = output.value.map((item: unknown) => {\n      if (item && typeof item === \"object\" && \"encryptedContent\" in item) {\n        // Remove encryptedContent but keep other fields\n        const { encryptedContent, ...rest } = item as Record<string, unknown>;\n        return rest;\n      }\n      return item;\n    });\n\n    return {\n      ...output,\n      value: strippedValue,\n    };\n  }\n\n  return output;\n}\n\n// Comprehensive stream info\ninterface WorkspaceStreamInfo {\n  state: StreamState;\n  streamResult: Awaited<ReturnType<typeof streamText>>;\n  abortController: AbortController;\n  messageId: string;\n  token: StreamToken;\n  startTime: number;\n  model: string;\n  initialMetadata?: Partial<CmuxMetadata>;\n  historySequence: number;\n  // Track accumulated parts for partial message (includes reasoning, text, and tools)\n  parts: CompletedMessagePart[];\n  // Track last partial write time for throttling\n  lastPartialWriteTime: number;\n  // Throttle timer for partial writes\n  partialWriteTimer?: NodeJS.Timeout;\n  // Track in-flight write to serialize writes\n  partialWritePromise?: Promise<void>;\n  // Track background processing promise for guaranteed cleanup\n  processingPromise: Promise<void>;\n}\n\n/**\n * StreamManager - Handles all streaming operations with type safety and atomic operations\n *\n * Key invariants:\n * - Only one active stream per workspace at any time\n * - Atomic stream creation/cancellation operations\n * - Guaranteed resource cleanup in all code paths\n */\nexport class StreamManager extends EventEmitter {\n  private workspaceStreams = new Map<WorkspaceId, WorkspaceStreamInfo>();\n  private streamLocks = new Map<WorkspaceId, AsyncMutex>();\n  private readonly PARTIAL_WRITE_THROTTLE_MS = 500;\n  private readonly historyService: HistoryService;\n  private readonly partialService: PartialService;\n\n  constructor(historyService: HistoryService, partialService: PartialService) {\n    super();\n    this.historyService = historyService;\n    this.partialService = partialService;\n  }\n\n  /**\n   * Write the current partial message to disk (throttled by mtime)\n   * Ensures writes happen during rapid streaming (crash-resilient)\n   */\n  private async schedulePartialWrite(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo\n  ): Promise<void> {\n    const now = Date.now();\n    const timeSinceLastWrite = now - streamInfo.lastPartialWriteTime;\n\n    // If enough time has passed, write immediately\n    if (timeSinceLastWrite >= this.PARTIAL_WRITE_THROTTLE_MS) {\n      await this.flushPartialWrite(workspaceId, streamInfo);\n      return;\n    }\n\n    // Otherwise, schedule write for remaining time (fire-and-forget for scheduled writes)\n    if (streamInfo.partialWriteTimer) {\n      clearTimeout(streamInfo.partialWriteTimer);\n    }\n\n    const remainingTime = this.PARTIAL_WRITE_THROTTLE_MS - timeSinceLastWrite;\n    streamInfo.partialWriteTimer = setTimeout(() => {\n      void this.flushPartialWrite(workspaceId, streamInfo);\n    }, remainingTime);\n  }\n\n  /**\n   * Flush any pending partial write and write immediately\n   * Serializes writes to prevent races - waits for any in-flight write before starting new one\n   */\n  private async flushPartialWrite(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo\n  ): Promise<void> {\n    // Wait for any in-flight write to complete first (serialization)\n    if (streamInfo.partialWritePromise) {\n      await streamInfo.partialWritePromise;\n    }\n\n    // Clear throttle timer\n    if (streamInfo.partialWriteTimer) {\n      clearTimeout(streamInfo.partialWriteTimer);\n      streamInfo.partialWriteTimer = undefined;\n    }\n\n    // Start new write and track the promise\n    streamInfo.partialWritePromise = (async () => {\n      try {\n        const partialMessage: CmuxMessage = {\n          id: streamInfo.messageId,\n          role: \"assistant\",\n          metadata: {\n            historySequence: streamInfo.historySequence,\n            timestamp: streamInfo.startTime,\n            model: streamInfo.model,\n            partial: true, // Always true - this method only writes partial messages\n            ...streamInfo.initialMetadata,\n          },\n          parts: streamInfo.parts, // Parts array includes reasoning, text, and tools\n        };\n\n        await this.partialService.writePartial(workspaceId as string, partialMessage);\n        streamInfo.lastPartialWriteTime = Date.now();\n      } catch (error) {\n        log.error(\"Failed to write partial message:\", error);\n      } finally {\n        // Clear promise when write completes\n        streamInfo.partialWritePromise = undefined;\n      }\n    })();\n\n    // Wait for this write to complete\n    await streamInfo.partialWritePromise;\n  }\n\n  /**\n   * Atomically ensures stream safety by cancelling any existing stream\n   * @param workspaceId The workspace to ensure stream safety for\n   * @returns A unique stream token for the new stream\n   */\n  private async ensureStreamSafety(workspaceId: WorkspaceId): Promise<StreamToken> {\n    const existing = this.workspaceStreams.get(workspaceId);\n\n    if (existing && existing.state !== StreamState.IDLE) {\n      await this.cancelStreamSafely(workspaceId, existing);\n    }\n\n    // Generate unique token for this stream\n    return randomUUID() as StreamToken;\n  }\n\n  /**\n   * Safely cancels an existing stream with proper cleanup\n   *\n   * CRITICAL: Waits for the processing promise to complete before cleanup.\n   * This ensures the old stream fully exits before a new stream can start,\n   * preventing concurrent streams and race conditions.\n   */\n  private async cancelStreamSafely(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo\n  ): Promise<void> {\n    try {\n      streamInfo.state = StreamState.STOPPING;\n\n      // Flush any pending partial write immediately (preserves work on interruption)\n      await this.flushPartialWrite(workspaceId, streamInfo);\n\n      streamInfo.abortController.abort();\n\n      // CRITICAL: Wait for processing to fully complete before cleanup\n      // This prevents race conditions where the old stream is still running\n      // while a new stream starts (e.g., old stream writing to partial.json)\n      await streamInfo.processingPromise;\n\n      // Emit abort event\n      this.emit(\"stream-abort\", {\n        type: \"stream-abort\",\n        workspaceId: workspaceId as string,\n        messageId: streamInfo.messageId,\n      });\n\n      // Clean up immediately\n      this.workspaceStreams.delete(workspaceId);\n    } catch (error) {\n      console.error(\"Error during stream cancellation:\", error);\n      // Force cleanup even if cancellation fails\n      this.workspaceStreams.delete(workspaceId);\n    }\n  }\n\n  /**\n   * Atomically creates a new stream with all necessary setup\n   */\n  private createStreamAtomically(\n    workspaceId: WorkspaceId,\n    streamToken: StreamToken,\n    messages: ModelMessage[],\n    model: LanguageModel,\n    modelString: string,\n    abortSignal: AbortSignal | undefined,\n    system: string,\n    historySequence: number,\n    tools?: Record<string, Tool>,\n    initialMetadata?: Partial<CmuxMetadata>,\n    providerOptions?: Record<string, unknown>,\n    maxOutputTokens?: number,\n    toolPolicy?: ToolPolicy\n  ): WorkspaceStreamInfo {\n    // Create abort controller for this specific stream\n    const abortController = new AbortController();\n\n    // Link external abort signal\n    if (abortSignal) {\n      abortSignal.addEventListener(\"abort\", () => abortController.abort());\n    }\n\n    // Determine toolChoice based on toolPolicy\n    // If a tool is required (tools object has exactly one tool after applyToolPolicy),\n    // force the model to use it with toolChoice: { type: \"required\", toolName: \"...\" }\n    let toolChoice: { type: \"required\"; toolName: string } | undefined;\n    if (tools && toolPolicy) {\n      // Check if any filter has \"require\" action\n      const hasRequireAction = toolPolicy.some((filter) => filter.action === \"require\");\n      if (hasRequireAction && Object.keys(tools).length === 1) {\n        const requiredToolName = Object.keys(tools)[0];\n        toolChoice = { type: \"required\", toolName: requiredToolName };\n        log.debug(\"Setting toolChoice to required\", { toolName: requiredToolName });\n      }\n    }\n\n    // Start streaming - this can throw immediately if API key is missing\n    let streamResult;\n    try {\n      streamResult = streamText({\n        model,\n        messages,\n        system,\n        abortSignal: abortController.signal,\n        tools,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n        toolChoice: toolChoice as any, // Force tool use when required by policy\n        // When toolChoice is set (required tool), limit to 1 step to prevent infinite loops\n        // Otherwise allow unlimited steps for multi-turn tool use\n        ...(toolChoice ? { maxSteps: 1 } : { stopWhen: stepCountIs(100000) }),\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n        providerOptions: providerOptions as any, // Pass provider-specific options (thinking/reasoning config)\n        // Default to 32000 tokens if not specified (Anthropic defaults to 4096)\n        maxOutputTokens: maxOutputTokens ?? 32000,\n      });\n    } catch (error) {\n      // Clean up abort controller if stream creation fails\n      abortController.abort();\n      // Re-throw the error to be caught by startStream\n      throw error;\n    }\n\n    const messageId = `assistant-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    const streamInfo: WorkspaceStreamInfo = {\n      state: StreamState.STARTING,\n      streamResult,\n      abortController,\n      messageId,\n      token: streamToken,\n      startTime: Date.now(),\n      model: modelString,\n      initialMetadata,\n      historySequence,\n      parts: [], // Initialize empty parts array\n      lastPartialWriteTime: 0, // Initialize to 0 to allow immediate first write\n      partialWritePromise: undefined, // No write in flight initially\n      processingPromise: Promise.resolve(), // Placeholder, overwritten in startStream\n    };\n\n    // Atomically register the stream\n    this.workspaceStreams.set(workspaceId, streamInfo);\n\n    return streamInfo;\n  }\n\n  /**\n   * Processes a stream with guaranteed cleanup, regardless of success or failure\n   */\n  private async processStreamWithCleanup(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    historySequence: number\n  ): Promise<void> {\n    try {\n      // Update state to streaming\n      streamInfo.state = StreamState.STREAMING;\n\n      // Emit stream start event\n      this.emit(\"stream-start\", {\n        type: \"stream-start\",\n        workspaceId: workspaceId as string,\n        messageId: streamInfo.messageId,\n        model: streamInfo.model,\n        historySequence,\n      } as StreamStartEvent);\n\n      // Use fullStream to capture all events including tool calls\n      const toolCalls = new Map<\n        string,\n        { toolCallId: string; toolName: string; input: unknown; output?: unknown }\n      >();\n\n      for await (const part of streamInfo.streamResult.fullStream) {\n        // Check if stream was cancelled BEFORE processing any parts\n        // This improves interruption responsiveness by catching aborts earlier\n        if (streamInfo.abortController.signal.aborted) {\n          log.debug(\"streamManager: Stream aborted, breaking from loop\");\n          break;\n        }\n\n        // Log all stream parts to debug reasoning (commented out - too spammy)\n        // log.debug(\"streamManager: Stream part\", {\n        //   type: part.type,\n        //   hasText: \"text\" in part,\n        //   preview: \"text\" in part ? (part as StreamPartWithText).text?.substring(0, 50) : undefined,\n        // });\n\n        switch (part.type) {\n          case \"text-delta\":\n            this.emit(\"stream-delta\", {\n              type: \"stream-delta\",\n              workspaceId: workspaceId as string,\n              messageId: streamInfo.messageId,\n              delta: part.text,\n            } as StreamDeltaEvent);\n\n            // Append each delta as a new part (merging happens at display time)\n            streamInfo.parts.push({\n              type: \"text\",\n              text: part.text,\n            });\n\n            // Schedule partial write (throttled, fire-and-forget to not block stream)\n            void this.schedulePartialWrite(workspaceId, streamInfo);\n            break;\n\n          case \"reasoning-delta\": {\n            // Both Anthropic and OpenAI use reasoning-delta for streaming reasoning content\n            const delta = (part as ReasoningDeltaPart).text ?? \"\";\n\n            // Append each delta as a new part (merging happens at display time)\n            streamInfo.parts.push({\n              type: \"reasoning\",\n              text: delta,\n            });\n\n            this.emit(\"reasoning-delta\", {\n              type: \"reasoning-delta\",\n              workspaceId: workspaceId as string,\n              messageId: streamInfo.messageId,\n              delta,\n            });\n            void this.schedulePartialWrite(workspaceId, streamInfo);\n            break;\n          }\n\n          case \"reasoning-end\": {\n            // Reasoning-end is just a signal - no state to update\n            this.emit(\"reasoning-end\", {\n              type: \"reasoning-end\",\n              workspaceId: workspaceId as string,\n              messageId: streamInfo.messageId,\n            });\n            break;\n          }\n\n          case \"tool-call\": {\n            // Tool call started - store in map for later lookup\n            toolCalls.set(part.toolCallId, {\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: part.input,\n            });\n\n            // IMPORTANT: Add tool part to streamInfo.parts immediately (not just on completion)\n            // This ensures in-progress tool calls are saved to partial.json if stream is interrupted\n            const toolPart = {\n              type: \"dynamic-tool\" as const,\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              state: \"input-available\" as const,\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n              input: part.input,\n            };\n            streamInfo.parts.push(toolPart);\n\n            this.emit(\"tool-call-start\", {\n              type: \"tool-call-start\",\n              workspaceId: workspaceId as string,\n              messageId: streamInfo.messageId,\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              args: part.input,\n            } as ToolCallStartEvent);\n            break;\n          }\n\n          case \"tool-result\": {\n            // Tool call completed - update the existing tool part with output\n            const toolCall = toolCalls.get(part.toolCallId);\n            if (toolCall) {\n              // Strip encrypted content from web search results before storing\n              const strippedOutput = stripEncryptedContent(part.output);\n              toolCall.output = strippedOutput;\n\n              // Find and update the existing tool part (added during tool-call)\n              const existingPartIndex = streamInfo.parts.findIndex(\n                (p) => p.type === \"dynamic-tool\" && p.toolCallId === part.toolCallId\n              );\n\n              if (existingPartIndex !== -1) {\n                // Update existing part with output\n                const existingPart = streamInfo.parts[existingPartIndex];\n                if (existingPart.type === \"dynamic-tool\") {\n                  streamInfo.parts[existingPartIndex] = {\n                    ...existingPart,\n                    state: \"output-available\" as const,\n                    output: strippedOutput,\n                  };\n                }\n              } else {\n                // Fallback: part not found (shouldn't happen), add it\n                streamInfo.parts.push({\n                  type: \"dynamic-tool\" as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  state: \"output-available\" as const,\n                  input: toolCall.input,\n                  output: strippedOutput,\n                });\n              }\n\n              this.emit(\"tool-call-end\", {\n                type: \"tool-call-end\",\n                workspaceId: workspaceId as string,\n                messageId: streamInfo.messageId,\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                result: strippedOutput,\n              } as ToolCallEndEvent);\n\n              // Schedule partial write after tool result (throttled, fire-and-forget)\n              void this.schedulePartialWrite(workspaceId, streamInfo);\n            }\n            break;\n          }\n\n          // Handle error parts from the stream (e.g., OpenAI context_length_exceeded)\n          case \"error\": {\n            // Capture the error and immediately throw to trigger error handling\n            // Error parts are structured errors from the AI SDK\n            const errorPart = part as { error: unknown };\n\n            // Try to extract error message from various possible structures\n            let errorMessage: string | undefined;\n\n            if (errorPart.error instanceof Error) {\n              throw errorPart.error;\n            } else if (typeof errorPart.error === \"object\" && errorPart.error !== null) {\n              const errorObj = errorPart.error as Record<string, unknown>;\n\n              // Check for nested error object with message (OpenAI format)\n              if (errorObj.error && typeof errorObj.error === \"object\" && errorObj.error !== null) {\n                const nestedError = errorObj.error as Record<string, unknown>;\n                if (typeof nestedError.message === \"string\") {\n                  errorMessage = nestedError.message;\n                }\n              }\n\n              // Fallback to direct message property\n              errorMessage ??= typeof errorObj.message === \"string\" ? errorObj.message : undefined;\n\n              // Last resort: stringify the error\n              errorMessage ??= JSON.stringify(errorObj);\n\n              const error = new Error(errorMessage);\n              // Preserve original error as cause for debugging\n              Object.assign(error, { cause: errorObj });\n              throw error;\n            } else {\n              throw new Error(String(errorPart.error));\n            }\n          }\n\n          // Handle other event types as needed\n          case \"start\":\n          case \"start-step\":\n          case \"text-start\":\n          case \"finish\":\n          case \"finish-step\":\n            // These events can be logged or handled if needed\n            break;\n        }\n      }\n\n      // No need to save remaining text - text-delta handler already maintains parts array\n      // (Removed duplicate push that was causing double text parts)\n\n      // Flush final state to partial.json for crash resilience\n      // This happens regardless of abort status to ensure the final state is persisted to disk\n      // On abort: second flush after cancelStreamSafely, ensures all streamed content is saved\n      // On normal completion: provides crash resilience before AIService writes to chat.jsonl\n      await this.flushPartialWrite(workspaceId, streamInfo);\n\n      // Check if stream completed successfully\n      if (!streamInfo.abortController.signal.aborted) {\n        // Get usage and provider metadata from stream result\n        const usage = await streamInfo.streamResult.usage;\n        const providerMetadata = await streamInfo.streamResult.providerMetadata;\n\n        // Emit stream end event with parts preserved in temporal order\n        const streamEndEvent: StreamEndEvent = {\n          type: \"stream-end\",\n          workspaceId: workspaceId as string,\n          messageId: streamInfo.messageId,\n          metadata: {\n            ...streamInfo.initialMetadata, // AIService-provided metadata (systemMessageTokens, etc)\n            model: streamInfo.model,\n            usage, // AI SDK normalized usage\n            providerMetadata, // Raw provider metadata\n            duration: Date.now() - streamInfo.startTime,\n          },\n          parts: streamInfo.parts, // Parts array with temporal ordering (includes reasoning)\n        };\n\n        this.emit(\"stream-end\", streamEndEvent);\n\n        // Update history with final message (only if there are parts)\n        if (streamInfo.parts && streamInfo.parts.length > 0) {\n          const finalAssistantMessage: CmuxMessage = {\n            id: streamInfo.messageId,\n            role: \"assistant\",\n            metadata: {\n              ...streamEndEvent.metadata,\n              historySequence: streamInfo.historySequence,\n            },\n            parts: streamInfo.parts,\n          };\n\n          // CRITICAL: Delete partial.json before updating chat.jsonl\n          // On successful completion, partial.json becomes stale and must be removed\n          await this.partialService.deletePartial(workspaceId as string);\n\n          // Update the placeholder message in chat.jsonl with final content\n          await this.historyService.updateHistory(workspaceId as string, finalAssistantMessage);\n        }\n      }\n    } catch (error) {\n      streamInfo.state = StreamState.ERROR;\n\n      // Log the actual error for debugging\n      console.error(\"Stream processing error:\", error);\n\n      // Extract error message (errors thrown from 'error' parts already have the correct message)\n      let errorMessage: string = error instanceof Error ? error.message : String(error);\n      let actualError: unknown = error;\n\n      // For categorization, use the cause if available (preserves the original error structure)\n      if (error instanceof Error && error.cause) {\n        actualError = error.cause;\n      }\n\n      let errorType = this.categorizeError(actualError);\n\n      // Detect and enhance model-not-found errors\n      if (APICallError.isInstance(actualError)) {\n        const apiError = actualError;\n\n        // Type guard for error data structure\n        const hasErrorProperty = (\n          data: unknown\n        ): data is { error: { code?: string; type?: string } } => {\n          return (\n            typeof data === \"object\" &&\n            data !== null &&\n            \"error\" in data &&\n            typeof data.error === \"object\" &&\n            data.error !== null\n          );\n        };\n\n        // OpenAI: 400 with error.code === 'model_not_found'\n        const isOpenAIModelError =\n          apiError.statusCode === 400 &&\n          hasErrorProperty(apiError.data) &&\n          apiError.data.error.code === \"model_not_found\";\n\n        // Anthropic: 404 with error.type === 'not_found_error'\n        const isAnthropicModelError =\n          apiError.statusCode === 404 &&\n          hasErrorProperty(apiError.data) &&\n          apiError.data.error.type === \"not_found_error\";\n\n        if (isOpenAIModelError || isAnthropicModelError) {\n          errorType = \"model_not_found\";\n          // Extract model name from model string (e.g., \"anthropic:sonnet-1m\" -> \"sonnet-1m\")\n          const [, modelName] = streamInfo.model.split(\":\");\n          errorMessage = `Model '${modelName || streamInfo.model}' does not exist or is not available. Please check your model selection.`;\n        }\n      }\n\n      // If we detect API key issues in the error message, override the type\n      if (\n        errorMessage.toLowerCase().includes(\"api key\") ||\n        errorMessage.toLowerCase().includes(\"api_key\") ||\n        errorMessage.toLowerCase().includes(\"anthropic_api_key\")\n      ) {\n        errorType = \"authentication\";\n      }\n\n      // Write error metadata to partial.json for persistence across reloads\n      const errorPartialMessage: CmuxMessage = {\n        id: streamInfo.messageId,\n        role: \"assistant\",\n        metadata: {\n          historySequence: streamInfo.historySequence,\n          timestamp: streamInfo.startTime,\n          model: streamInfo.model,\n          partial: true,\n          error: errorMessage,\n          errorType,\n          ...streamInfo.initialMetadata,\n        },\n        parts: streamInfo.parts,\n      };\n      // Write error state to disk (fire-and-forget to not block error emission)\n      void this.partialService.writePartial(workspaceId as string, errorPartialMessage);\n\n      // Emit error event\n      this.emit(\"error\", {\n        type: \"error\",\n        workspaceId: workspaceId as string,\n        messageId: streamInfo.messageId,\n        error: errorMessage,\n        errorType: errorType,\n      } as ErrorEvent);\n    } finally {\n      // Guaranteed cleanup in all code paths\n      // Clear any pending timers to prevent keeping process alive\n      if (streamInfo.partialWriteTimer) {\n        clearTimeout(streamInfo.partialWriteTimer);\n        streamInfo.partialWriteTimer = undefined;\n      }\n      this.workspaceStreams.delete(workspaceId);\n    }\n  }\n\n  /**\n   * Converts errors to strongly-typed SendMessageError\n   */\n  private convertToSendMessageError(error: unknown): SendMessageError {\n    // Check for specific AI SDK errors using type guards\n    if (LoadAPIKeyError.isInstance(error)) {\n      return {\n        type: \"api_key_not_found\",\n        provider: \"anthropic\", // We can infer this from LoadAPIKeyError context\n      };\n    }\n\n    // TODO: Add more specific error types as needed\n    // if (APICallError.isInstance(error)) {\n    //   if (error.statusCode === 401) return { type: \"authentication\", ... };\n    //   if (error.statusCode === 429) return { type: \"rate_limit\", ... };\n    // }\n    // if (RetryError.isInstance(error)) {\n    //   return { type: \"retry_failed\", ... };\n    // }\n\n    // Fallback for unknown errors\n    const message = error instanceof Error ? error.message : String(error);\n    return { type: \"unknown\", raw: message };\n  }\n\n  /**\n   * Categorizes errors for better error handling (used for event emission)\n   */\n  private categorizeError(error: unknown): StreamErrorType {\n    // Use AI SDK error type guards first\n    if (LoadAPIKeyError.isInstance(error)) {\n      return \"authentication\";\n    }\n    if (APICallError.isInstance(error)) {\n      if (error.statusCode === 401) return \"authentication\";\n      if (error.statusCode === 429) return \"rate_limit\";\n      if (error.statusCode && error.statusCode >= 500) return \"server_error\";\n\n      // Check for Anthropic context exceeded errors\n      if (error.message.includes(\"prompt is too long:\")) {\n        return \"context_exceeded\";\n      }\n\n      return \"api\";\n    }\n    if (RetryError.isInstance(error)) {\n      return \"retry_failed\";\n    }\n\n    // Check for OpenAI/Anthropic structured error format (from error.cause)\n    // Structure: { error: { code: 'context_length_exceeded', type: '...', message: '...' } }\n    if (\n      typeof error === \"object\" &&\n      error !== null &&\n      \"error\" in error &&\n      typeof error.error === \"object\" &&\n      error.error !== null\n    ) {\n      const structuredError = error.error as { code?: string; type?: string };\n\n      // OpenAI context length errors have code: 'context_length_exceeded'\n      if (structuredError.code === \"context_length_exceeded\") {\n        return \"context_exceeded\";\n      }\n\n      // Check for other specific error codes/types\n      if (structuredError.code === \"rate_limit_exceeded\") {\n        return \"rate_limit\";\n      }\n    }\n\n    // Fall back to string matching for other errors\n    if (error instanceof Error) {\n      const message = error.message.toLowerCase();\n\n      if (error.name === \"AbortError\" || message.includes(\"abort\")) {\n        return \"aborted\";\n      } else if (message.includes(\"network\") || message.includes(\"fetch\")) {\n        return \"network\";\n      } else if (\n        message.includes(\"token\") ||\n        message.includes(\"context\") ||\n        message.includes(\"too long\") ||\n        message.includes(\"maximum\")\n      ) {\n        return \"context_exceeded\";\n      } else if (message.includes(\"quota\") || message.includes(\"limit\")) {\n        return \"quota\";\n      } else if (message.includes(\"auth\") || message.includes(\"key\")) {\n        return \"authentication\";\n      } else {\n        return \"api\";\n      }\n    }\n\n    return \"unknown\";\n  }\n\n  /**\n   * Starts a new stream for a workspace, automatically cancelling any existing stream\n   *\n   * Uses per-workspace mutex to prevent concurrent streams. The mutex ensures:\n   * 1. Only one startStream can execute at a time per workspace\n   * 2. Old stream fully exits before new stream starts\n   * 3. No race conditions in stream registration or cleanup\n   */\n  async startStream(\n    workspaceId: string,\n    messages: ModelMessage[],\n    model: LanguageModel,\n    modelString: string,\n    historySequence: number,\n    system: string,\n    abortSignal?: AbortSignal,\n    tools?: Record<string, Tool>,\n    initialMetadata?: Partial<CmuxMetadata>,\n    providerOptions?: Record<string, unknown>,\n    maxOutputTokens?: number,\n    toolPolicy?: ToolPolicy\n  ): Promise<Result<StreamToken, SendMessageError>> {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n\n    // Get or create mutex for this workspace\n    if (!this.streamLocks.has(typedWorkspaceId)) {\n      this.streamLocks.set(typedWorkspaceId, new AsyncMutex());\n    }\n    const mutex = this.streamLocks.get(typedWorkspaceId)!;\n\n    try {\n      // Acquire lock - guarantees only one startStream per workspace\n      // Lock is automatically released when scope exits via Symbol.asyncDispose\n      await using _lock = await mutex.acquire();\n\n      // DEBUG: Log stream start\n      log.debug(\n        `[STREAM START] workspaceId=${workspaceId} historySequence=${historySequence} model=${modelString}`\n      );\n\n      // Step 1: Atomic safety check (cancels any existing stream and waits for full exit)\n      const streamToken = await this.ensureStreamSafety(typedWorkspaceId);\n\n      // Step 2: Atomic stream creation and registration\n      const streamInfo = this.createStreamAtomically(\n        typedWorkspaceId,\n        streamToken,\n        messages,\n        model,\n        modelString,\n        abortSignal,\n        system,\n        historySequence,\n        tools,\n        initialMetadata,\n        providerOptions,\n        maxOutputTokens,\n        toolPolicy\n      );\n\n      // Step 3: Track the processing promise for guaranteed cleanup\n      // This allows cancelStreamSafely to wait for full exit\n      streamInfo.processingPromise = this.processStreamWithCleanup(\n        typedWorkspaceId,\n        streamInfo,\n        historySequence\n      ).catch((error) => {\n        console.error(\"Unexpected error in stream processing:\", error);\n      });\n\n      return Ok(streamToken);\n    } catch (error) {\n      // Guaranteed cleanup on any failure\n      this.workspaceStreams.delete(typedWorkspaceId);\n      // Convert to strongly-typed error\n      return Err(this.convertToSendMessageError(error));\n    }\n  }\n\n  /**\n   * Stops an active stream for a workspace\n   */\n  async stopStream(workspaceId: string): Promise<Result<void>> {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n\n    try {\n      const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n      if (streamInfo) {\n        await this.cancelStreamSafely(typedWorkspaceId, streamInfo);\n      }\n      return Ok(undefined);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to stop stream: ${message}`);\n    }\n  }\n\n  /**\n   * Gets the current stream state for a workspace\n   */\n  getStreamState(workspaceId: string): StreamState {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n    return streamInfo?.state ?? StreamState.IDLE;\n  }\n\n  /**\n   * Checks if a workspace currently has an active stream\n   */\n  isStreaming(workspaceId: string): boolean {\n    const state = this.getStreamState(workspaceId);\n    return state === StreamState.STARTING || state === StreamState.STREAMING;\n  }\n\n  /**\n   * Gets all active workspace streams (for debugging/monitoring)\n   */\n  getActiveStreams(): string[] {\n    return Array.from(this.workspaceStreams.keys()).map((id) => id as string);\n  }\n\n  /**\n   * Gets the current stream info for a workspace if actively streaming\n   * Returns undefined if no active stream exists\n   * Used to re-establish streaming context on frontend reconnection\n   */\n  getStreamInfo(\n    workspaceId: string\n  ):\n    | { messageId: string; model: string; historySequence: number; parts: CompletedMessagePart[] }\n    | undefined {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n\n    // Only return info if stream is actively running\n    if (\n      streamInfo &&\n      (streamInfo.state === StreamState.STARTING || streamInfo.state === StreamState.STREAMING)\n    ) {\n      return {\n        messageId: streamInfo.messageId,\n        model: streamInfo.model,\n        historySequence: streamInfo.historySequence,\n        parts: streamInfo.parts,\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Replay stream events\n   * Emits the same events (stream-start, stream-delta, etc.) that would be emitted during live streaming\n   * This allows replay to flow through the same event path as live streaming (no duplication)\n   */\n  replayStream(workspaceId: string): void {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n\n    // Only replay if stream is actively running\n    if (\n      !streamInfo ||\n      (streamInfo.state !== StreamState.STARTING && streamInfo.state !== StreamState.STREAMING)\n    ) {\n      return;\n    }\n\n    // Emit stream-start event\n    this.emit(\"stream-start\", {\n      type: \"stream-start\",\n      workspaceId,\n      messageId: streamInfo.messageId,\n      model: streamInfo.model,\n      historySequence: streamInfo.historySequence,\n    });\n\n    // Replay accumulated parts as events\n    for (const part of streamInfo.parts) {\n      if (part.type === \"text\") {\n        this.emit(\"stream-delta\", {\n          type: \"stream-delta\",\n          workspaceId,\n          messageId: streamInfo.messageId,\n          delta: part.text,\n        });\n      } else if (part.type === \"reasoning\") {\n        this.emit(\"reasoning-delta\", {\n          type: \"reasoning-delta\",\n          workspaceId,\n          messageId: streamInfo.messageId,\n          delta: part.text,\n        });\n      } else if (part.type === \"dynamic-tool\") {\n        // Emit tool-call-start\n        this.emit(\"tool-call-start\", {\n          type: \"tool-call-start\",\n          workspaceId,\n          messageId: streamInfo.messageId,\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          args: part.input,\n        });\n\n        // If tool has output, emit tool-call-end\n        if (part.state === \"output-available\") {\n          this.emit(\"tool-call-end\", {\n            type: \"tool-call-end\",\n            workspaceId,\n            messageId: streamInfo.messageId,\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            result: part.output,\n          });\n        }\n      }\n    }\n  }\n}\n"]}