{"version":3,"file":"StreamingMessageAggregator.js","sourceRoot":"","sources":["../../../src/utils/messages/StreamingMessageAggregator.ts"],"names":[],"mappings":"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","sourcesContent":["import type { CmuxMessage, CmuxMetadata, DisplayedMessage } from \"@/types/message\";\nimport { createCmuxMessage } from \"@/types/message\";\nimport type {\n  StreamStartEvent,\n  StreamDeltaEvent,\n  StreamEndEvent,\n  StreamAbortEvent,\n  ToolCallStartEvent,\n  ToolCallDeltaEvent,\n  ToolCallEndEvent,\n  ReasoningDeltaEvent,\n  ReasoningEndEvent,\n} from \"@/types/stream\";\nimport type { WorkspaceChatMessage, StreamErrorMessage, DeleteMessage } from \"@/types/ipc\";\nimport type {\n  DynamicToolPart,\n  DynamicToolPartPending,\n  DynamicToolPartAvailable,\n} from \"@/types/toolParts\";\nimport { isDynamicToolPart } from \"@/types/toolParts\";\n\n// Maximum number of messages to display in the DOM for performance\n// Full history is still maintained internally for token counting and stats\nconst MAX_DISPLAYED_MESSAGES = 128;\n\ninterface StreamingContext {\n  startTime: number;\n  isComplete: boolean;\n  isCompacting: boolean;\n  model: string;\n}\n\n/**\n * StreamingMessageAggregator - Simplified for User/Assistant Messages Only\n *\n * PURPOSE:\n * This class aggregates messages and handles streaming state for a simple\n * chat interface with only user and assistant messages.\n *\n * RULES:\n * 1. NO FORMATTING: Do not add emojis, format text, or create display strings\n * 2. NO PRESENTATION LOGIC: Do not make decisions about how messages should look\n * 3. RAW DATA ONLY: Store messages as close to their original format as possible\n * 4. STRUCTURE ONLY: Only transform data structure (e.g., streaming to final messages)\n */\nexport class StreamingMessageAggregator {\n  private messages = new Map<string, CmuxMessage>();\n  private activeStreams = new Map<string, StreamingContext>();\n  private streamSequenceCounter = 0; // For ordering parts within a streaming message\n\n  // Cache for getAllMessages() to maintain stable array references\n  private cachedMessages: CmuxMessage[] | null = null;\n\n  // Invalidate cache on any mutation\n  private invalidateCache(): void {\n    this.cachedMessages = null;\n  }\n\n  addMessage(message: CmuxMessage): void {\n    // Just store the message - backend assigns historySequence\n    this.messages.set(message.id, message);\n    this.invalidateCache();\n  }\n\n  /**\n   * Load historical messages in batch, preserving their historySequence numbers.\n   * This is more efficient than calling addMessage() repeatedly.\n   */\n  loadHistoricalMessages(messages: CmuxMessage[]): void {\n    for (const message of messages) {\n      this.messages.set(message.id, message);\n    }\n    this.invalidateCache();\n  }\n\n  getAllMessages(): CmuxMessage[] {\n    if (this.cachedMessages) {\n      return this.cachedMessages;\n    }\n\n    this.cachedMessages = Array.from(this.messages.values()).sort(\n      (a, b) => (a.metadata?.historySequence ?? 0) - (b.metadata?.historySequence ?? 0)\n    );\n    return this.cachedMessages;\n  }\n\n  // Efficient methods to check message state without creating arrays\n  getMessageCount(): number {\n    return this.messages.size;\n  }\n\n  hasMessages(): boolean {\n    return this.messages.size > 0;\n  }\n\n  getActiveStreams(): StreamingContext[] {\n    return Array.from(this.activeStreams.values());\n  }\n\n  isCompacting(): boolean {\n    for (const context of this.activeStreams.values()) {\n      if (context.isCompacting) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getCurrentModel(): string | undefined {\n    // If there's an active stream, return its model\n    for (const context of this.activeStreams.values()) {\n      return context.model;\n    }\n\n    // Otherwise, return the model from the most recent assistant message\n    const messages = this.getAllMessages();\n    for (let i = messages.length - 1; i >= 0; i--) {\n      const message = messages[i];\n      if (message.role === \"assistant\" && message.metadata?.model) {\n        return message.metadata.model;\n      }\n    }\n\n    return undefined;\n  }\n\n  clearActiveStreams(): void {\n    this.activeStreams.clear();\n  }\n\n  clear(): void {\n    this.messages.clear();\n    this.activeStreams.clear();\n    this.streamSequenceCounter = 0;\n    this.invalidateCache();\n  }\n\n  /**\n   * Remove messages with specific historySequence numbers\n   * Used when backend truncates history\n   */\n  handleDeleteMessage(deleteMsg: DeleteMessage): void {\n    const sequencesToDelete = new Set(deleteMsg.historySequences);\n\n    // Remove messages that match the historySequence numbers\n    for (const [messageId, message] of this.messages.entries()) {\n      const historySeq = message.metadata?.historySequence;\n      if (historySeq !== undefined && sequencesToDelete.has(historySeq)) {\n        this.messages.delete(messageId);\n      }\n    }\n\n    this.invalidateCache();\n  }\n\n  // Unified event handlers that encapsulate all complex logic\n  handleStreamStart(data: StreamStartEvent): void {\n    // Detect if this stream is compacting by checking last user message's toolPolicy\n    const messages = this.getAllMessages();\n    const lastUserMsg = [...messages].reverse().find((m) => m.role === \"user\");\n    const isCompacting =\n      lastUserMsg?.metadata?.toolPolicy?.some(\n        (filter) =>\n          filter.action === \"require\" &&\n          new RegExp(`^${filter.regex_match}$`).test(\"compact_summary\")\n      ) ?? false;\n\n    const context: StreamingContext = {\n      startTime: Date.now(),\n      isComplete: false,\n      isCompacting,\n      model: data.model,\n    };\n\n    // Use messageId as key - ensures only ONE stream per message\n    // If called twice (e.g., during replay), second call safely overwrites first\n    this.activeStreams.set(data.messageId, context);\n\n    // Create initial streaming message with empty parts (deltas will append)\n    const streamingMessage = createCmuxMessage(data.messageId, \"assistant\", \"\", {\n      historySequence: data.historySequence,\n      timestamp: Date.now(),\n      model: data.model,\n    });\n\n    this.messages.set(data.messageId, streamingMessage);\n    this.invalidateCache();\n  }\n\n  handleStreamDelta(data: StreamDeltaEvent): void {\n    const message = this.messages.get(data.messageId);\n    if (!message) return;\n\n    // Append each delta as a new part (merging happens at display time)\n    message.parts.push({\n      type: \"text\",\n      text: data.delta,\n    });\n    this.invalidateCache();\n  }\n\n  handleStreamEnd(data: StreamEndEvent): void {\n    // Direct lookup by messageId - O(1) instead of O(n) find\n    const activeStream = this.activeStreams.get(data.messageId);\n\n    if (activeStream) {\n      // Normal streaming case: we've been tracking this stream from the start\n      const message = this.messages.get(data.messageId);\n      if (message?.metadata) {\n        // Transparent metadata merge - backend fields flow through automatically\n        const updatedMetadata: CmuxMetadata = {\n          ...message.metadata,\n          ...data.metadata,\n          duration: Date.now() - activeStream.startTime,\n        };\n        message.metadata = updatedMetadata;\n\n        // Update tool parts with their results if provided\n        if (data.parts) {\n          // Sync up the tool results from the backend's parts array\n          for (const backendPart of data.parts) {\n            if (backendPart.type === \"dynamic-tool\") {\n              // Find and update existing tool part\n              const toolPart = message.parts.find(\n                (part): part is DynamicToolPart =>\n                  part.type === \"dynamic-tool\" &&\n                  (part as DynamicToolPart).toolCallId === backendPart.toolCallId\n              );\n              if (toolPart) {\n                // Update with result from backend\n                (toolPart as DynamicToolPartAvailable).output = backendPart.output;\n                (toolPart as DynamicToolPartAvailable).state = \"output-available\";\n              }\n            }\n          }\n        }\n      }\n\n      // Clean up active stream - direct delete by messageId\n      this.activeStreams.delete(data.messageId);\n    } else {\n      // Reconnection case: user reconnected after stream completed\n      // We reconstruct the entire message from the stream-end event\n      // The backend now sends us the parts array with proper temporal ordering\n      // Backend MUST provide historySequence in metadata\n\n      // Create the complete message\n      const message: CmuxMessage = {\n        id: data.messageId,\n        role: \"assistant\",\n        metadata: {\n          ...data.metadata,\n          timestamp: Date.now(),\n        },\n        parts: data.parts,\n      };\n\n      this.messages.set(data.messageId, message);\n    }\n    this.invalidateCache();\n  }\n\n  handleStreamAbort(data: StreamAbortEvent): void {\n    // Direct lookup by messageId\n    const activeStream = this.activeStreams.get(data.messageId);\n\n    if (activeStream) {\n      // Mark the message as interrupted\n      const message = this.messages.get(data.messageId);\n      if (message?.metadata) {\n        message.metadata.partial = true;\n      }\n\n      // Clean up active stream - direct delete by messageId\n      this.activeStreams.delete(data.messageId);\n      this.invalidateCache();\n    }\n  }\n\n  handleStreamError(data: StreamErrorMessage): void {\n    // Direct lookup by messageId\n    const activeStream = this.activeStreams.get(data.messageId);\n\n    if (activeStream) {\n      // Mark the message with error metadata\n      const message = this.messages.get(data.messageId);\n      if (message?.metadata) {\n        message.metadata.partial = true;\n        message.metadata.error = data.error;\n        message.metadata.errorType = data.errorType;\n      }\n\n      // Clean up active stream - direct delete by messageId\n      this.activeStreams.delete(data.messageId);\n      this.invalidateCache();\n    }\n  }\n\n  handleToolCallStart(data: ToolCallStartEvent): void {\n    const message = this.messages.get(data.messageId);\n    if (!message) return;\n\n    // Check if this tool call already exists to prevent duplicates\n    const existingToolPart = message.parts.find(\n      (part): part is DynamicToolPart =>\n        part.type === \"dynamic-tool\" && (part as DynamicToolPart).toolCallId === data.toolCallId\n    );\n\n    if (existingToolPart) {\n      console.warn(`Tool call ${data.toolCallId} already exists, skipping duplicate`);\n      return;\n    }\n\n    // Add tool part to maintain temporal order\n    const toolPart: DynamicToolPartPending = {\n      type: \"dynamic-tool\",\n      toolCallId: data.toolCallId,\n      toolName: data.toolName,\n      state: \"input-available\",\n      input: data.args,\n    };\n    message.parts.push(toolPart as never);\n    this.invalidateCache();\n  }\n\n  handleToolCallDelta(_data: ToolCallDeltaEvent): void {\n    // Tool deltas could be handled here if needed for streaming tool results\n    // For now, we wait for the complete result in handleToolCallEnd\n  }\n\n  handleToolCallEnd(data: ToolCallEndEvent): void {\n    const message = this.messages.get(data.messageId);\n    if (message) {\n      // Find the specific tool part by its ID and update it with the result\n      // We don't move it - it stays in its original temporal position\n      const toolPart = message.parts.find(\n        (part): part is DynamicToolPart =>\n          part.type === \"dynamic-tool\" && part.toolCallId === data.toolCallId\n      );\n      if (toolPart) {\n        // Type assertion needed because TypeScript can't narrow the discriminated union\n        (toolPart as DynamicToolPartAvailable).state = \"output-available\";\n        (toolPart as DynamicToolPartAvailable).output = data.result;\n      }\n      this.invalidateCache();\n    }\n  }\n\n  handleReasoningDelta(data: ReasoningDeltaEvent): void {\n    const message = this.messages.get(data.messageId);\n    if (!message) return;\n\n    // Append each delta as a new part (merging happens at display time)\n    message.parts.push({\n      type: \"reasoning\",\n      text: data.delta,\n    });\n    this.invalidateCache();\n  }\n\n  handleReasoningEnd(_data: ReasoningEndEvent): void {\n    // Reasoning-end is just a signal - no state to update\n    // Streaming status is inferred from activeStreams in getDisplayedMessages\n    this.invalidateCache();\n  }\n\n  handleMessage(data: WorkspaceChatMessage): void {\n    // Handle regular messages (user messages, historical messages)\n    // Check if it's a CmuxMessage (has role property but no type)\n    if (\"role\" in data && !(\"type\" in data)) {\n      const incomingMessage = data;\n\n      // Smart replacement logic for edits:\n      // If a message arrives with a historySequence that already exists,\n      // it means history was truncated (edit operation). Remove the existing\n      // message at that sequence and all subsequent messages, then add the new one.\n      const incomingSequence = incomingMessage.metadata?.historySequence;\n      if (incomingSequence !== undefined) {\n        // Check if there's already a message with this sequence\n        for (const [_id, msg] of this.messages.entries()) {\n          const existingSequence = msg.metadata?.historySequence;\n          if (existingSequence !== undefined && existingSequence >= incomingSequence) {\n            // Found a conflict - remove this message and all after it\n            const messagesToRemove: string[] = [];\n            for (const [removeId, removeMsg] of this.messages.entries()) {\n              const removeSeq = removeMsg.metadata?.historySequence;\n              if (removeSeq !== undefined && removeSeq >= incomingSequence) {\n                messagesToRemove.push(removeId);\n              }\n            }\n            for (const removeId of messagesToRemove) {\n              this.messages.delete(removeId);\n            }\n            break; // Found and handled the conflict\n          }\n        }\n      }\n\n      // Now add the new message\n      this.addMessage(incomingMessage);\n    }\n  }\n\n  /**\n   * Transform CmuxMessages into DisplayedMessages for UI consumption\n   * This splits complex messages with multiple parts into separate UI blocks\n   * while preserving temporal ordering through sequence numbers\n   */\n  getDisplayedMessages(): DisplayedMessage[] {\n    const displayedMessages: DisplayedMessage[] = [];\n\n    for (const message of this.getAllMessages()) {\n      const baseTimestamp = message.metadata?.timestamp;\n      // Get historySequence from backend (required field)\n      const historySequence = message.metadata?.historySequence ?? 0;\n\n      if (message.role === \"user\") {\n        // User messages: combine all text parts into single block\n        const content = message.parts\n          .filter((p) => p.type === \"text\")\n          .map((p) => p.text)\n          .join(\"\");\n\n        displayedMessages.push({\n          type: \"user\",\n          id: message.id,\n          historyId: message.id,\n          content,\n          historySequence,\n          timestamp: baseTimestamp,\n        });\n      } else if (message.role === \"assistant\") {\n        // Assistant messages: each part becomes a separate DisplayedMessage\n        // Use streamSequence to order parts within this message\n        let streamSeq = 0;\n\n        // Check if this message has an active stream (for inferring streaming status)\n        // Direct Map.has() check - O(1) instead of O(n) iteration\n        const hasActiveStream = this.activeStreams.has(message.id);\n\n        // Merge adjacent parts of same type (text with text, reasoning with reasoning)\n        // This is where all merging happens - streaming just appends raw deltas\n        const mergedParts: typeof message.parts = [];\n        for (const part of message.parts) {\n          const lastMerged = mergedParts[mergedParts.length - 1];\n\n          // Try to merge with last part if same type\n          if (lastMerged?.type === \"text\" && part.type === \"text\") {\n            // Merge text parts\n            mergedParts[mergedParts.length - 1] = {\n              type: \"text\",\n              text: lastMerged.text + part.text,\n            };\n          } else if (lastMerged?.type === \"reasoning\" && part.type === \"reasoning\") {\n            // Merge reasoning parts\n            mergedParts[mergedParts.length - 1] = {\n              type: \"reasoning\",\n              text: lastMerged.text + part.text,\n            };\n          } else {\n            // Different type or tool part - add new part\n            mergedParts.push(part);\n          }\n        }\n\n        // Find the last part that will produce a DisplayedMessage\n        // (reasoning, text parts with content, OR tool parts)\n        let lastPartIndex = -1;\n        for (let i = mergedParts.length - 1; i >= 0; i--) {\n          const part = mergedParts[i];\n          if (\n            part.type === \"reasoning\" ||\n            (part.type === \"text\" && part.text) ||\n            isDynamicToolPart(part)\n          ) {\n            lastPartIndex = i;\n            break;\n          }\n        }\n\n        mergedParts.forEach((part, partIndex) => {\n          const isLastPart = partIndex === lastPartIndex;\n          // Part is streaming if: active stream exists AND this is the last part\n          const isStreaming = hasActiveStream && isLastPart;\n\n          if (part.type === \"reasoning\") {\n            // Reasoning part - shows thinking/reasoning content\n            displayedMessages.push({\n              type: \"reasoning\",\n              id: `${message.id}-${partIndex}`,\n              historyId: message.id,\n              content: part.text,\n              historySequence,\n              streamSequence: streamSeq++,\n              isStreaming,\n              isPartial: message.metadata?.partial ?? false,\n              isLastPartOfMessage: isLastPart,\n              timestamp: baseTimestamp,\n            });\n          } else if (part.type === \"text\" && part.text) {\n            // Skip empty text parts\n            displayedMessages.push({\n              type: \"assistant\",\n              id: `${message.id}-${partIndex}`,\n              historyId: message.id,\n              content: part.text,\n              historySequence,\n              streamSequence: streamSeq++,\n              isStreaming,\n              isPartial: message.metadata?.partial ?? false,\n              isLastPartOfMessage: isLastPart,\n              isCompacted: message.metadata?.compacted ?? false,\n              model: message.metadata?.model,\n              timestamp: baseTimestamp,\n            });\n          } else if (isDynamicToolPart(part)) {\n            const status =\n              part.state === \"output-available\"\n                ? \"completed\"\n                : part.state === \"input-available\" && message.metadata?.partial\n                  ? \"interrupted\"\n                  : part.state === \"input-available\"\n                    ? \"executing\"\n                    : \"pending\";\n\n            displayedMessages.push({\n              type: \"tool\",\n              id: `${message.id}-${partIndex}`,\n              historyId: message.id,\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              args: part.input,\n              result: part.state === \"output-available\" ? part.output : undefined,\n              status,\n              isPartial: message.metadata?.partial ?? false,\n              historySequence,\n              streamSequence: streamSeq++,\n              isLastPartOfMessage: isLastPart,\n              timestamp: baseTimestamp,\n            });\n          }\n        });\n\n        // Create stream-error DisplayedMessage if message has error metadata\n        // This happens after all parts are displayed, so error appears at the end\n        if (message.metadata?.error) {\n          displayedMessages.push({\n            type: \"stream-error\",\n            id: `${message.id}-error`,\n            historyId: message.id,\n            error: message.metadata.error,\n            errorType: message.metadata.errorType ?? \"unknown\",\n            historySequence,\n            model: message.metadata.model,\n            timestamp: baseTimestamp,\n          });\n        }\n      }\n    }\n\n    // Limit to last N messages for DOM performance\n    // Full history is still maintained internally for token counting\n    if (displayedMessages.length > MAX_DISPLAYED_MESSAGES) {\n      const hiddenCount = displayedMessages.length - MAX_DISPLAYED_MESSAGES;\n      const slicedMessages = displayedMessages.slice(-MAX_DISPLAYED_MESSAGES);\n\n      // Add history-hidden indicator as the first message\n      const historyHiddenMessage: DisplayedMessage = {\n        type: \"history-hidden\",\n        id: \"history-hidden\",\n        hiddenCount,\n        historySequence: -1, // Place it before all messages\n      };\n\n      return [historyHiddenMessage, ...slicedMessages];\n    }\n\n    return displayedMessages;\n  }\n}\n"]}