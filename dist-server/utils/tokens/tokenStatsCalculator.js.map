{"version":3,"file":"tokenStatsCalculator.js","sourceRoot":"","sources":["../../../src/utils/tokens/tokenStatsCalculator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Shared token statistics calculation logic\n * Used by both frontend (ChatContext) and backend (debug commands)\n *\n * IMPORTANT: This utility is intentionally abstracted so that the debug command\n * (`bun debug costs`) has exact parity with the UI display in the Costs tab.\n * Any changes to token calculation logic should be made here to maintain consistency.\n */\n\nimport type { CmuxMessage } from \"@/types/message\";\nimport type { ChatStats, TokenConsumer } from \"@/types/chatStats\";\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\nimport { getTokenizerForModel, countTokensForData, getToolDefinitionTokens } from \"./tokenizer\";\nimport { getModelStats } from \"./modelStats\";\n\nexport interface ChatUsageComponent {\n  tokens: number;\n  cost_usd?: number; // undefined if model pricing unknown\n}\n\n/**\n * Enhanced usage type for display that includes provider-specific cache stats\n */\nexport interface ChatUsageDisplay {\n  // Input is the part of the input that was not cached. So,\n  // totalInput = input + cached (cacheCreate is separate for billing)\n  input: ChatUsageComponent;\n  cached: ChatUsageComponent;\n  cacheCreate: ChatUsageComponent; // Cache creation tokens (separate billing concept)\n\n  // Output is the part of the output excluding reasoning, so\n  // totalOutput = output + reasoning\n  output: ChatUsageComponent;\n  reasoning: ChatUsageComponent;\n}\n\n/**\n * Create a display-friendly usage object from AI SDK usage\n */\nexport function createDisplayUsage(\n  usage: LanguageModelV2Usage | undefined,\n  model: string,\n  providerMetadata?: Record<string, unknown>\n): ChatUsageDisplay | undefined {\n  if (!usage) return undefined;\n\n  // Provider-specific token handling:\n  // - OpenAI: inputTokens is INCLUSIVE of cachedInputTokens\n  // - Anthropic: inputTokens EXCLUDES cachedInputTokens\n  const cachedTokens = usage.cachedInputTokens ?? 0;\n  const rawInputTokens = usage.inputTokens ?? 0;\n\n  // Detect provider from model string\n  const isOpenAI = model.startsWith(\"openai:\");\n\n  // For OpenAI, subtract cached tokens to get uncached input tokens\n  const inputTokens = isOpenAI ? Math.max(0, rawInputTokens - cachedTokens) : rawInputTokens;\n\n  // Extract cache creation tokens from provider metadata (Anthropic-specific)\n  const cacheCreateTokens =\n    (providerMetadata?.anthropic as { cacheCreationInputTokens?: number } | undefined)\n      ?.cacheCreationInputTokens ?? 0;\n\n  // Calculate output tokens excluding reasoning\n  const outputWithoutReasoning = Math.max(\n    0,\n    (usage.outputTokens ?? 0) - (usage.reasoningTokens ?? 0)\n  );\n\n  // Get model stats for cost calculation\n  const modelStats = getModelStats(model);\n\n  // Calculate costs based on model stats (undefined if model unknown)\n  let inputCost: number | undefined;\n  let cachedCost: number | undefined;\n  let cacheCreateCost: number | undefined;\n  let outputCost: number | undefined;\n  let reasoningCost: number | undefined;\n\n  if (modelStats) {\n    inputCost = inputTokens * modelStats.input_cost_per_token;\n    cachedCost = cachedTokens * (modelStats.cache_read_input_token_cost ?? 0);\n    cacheCreateCost = cacheCreateTokens * (modelStats.cache_creation_input_token_cost ?? 0);\n    outputCost = outputWithoutReasoning * modelStats.output_cost_per_token;\n    reasoningCost = (usage.reasoningTokens ?? 0) * modelStats.output_cost_per_token;\n  }\n\n  return {\n    input: {\n      tokens: inputTokens,\n      cost_usd: inputCost,\n    },\n    cached: {\n      tokens: cachedTokens,\n      cost_usd: cachedCost,\n    },\n    cacheCreate: {\n      tokens: cacheCreateTokens,\n      cost_usd: cacheCreateCost,\n    },\n    output: {\n      tokens: outputWithoutReasoning,\n      cost_usd: outputCost,\n    },\n    reasoning: {\n      tokens: usage.reasoningTokens ?? 0,\n      cost_usd: reasoningCost,\n    },\n  };\n}\n\n/**\n * Sum multiple ChatUsageDisplay objects into a single cumulative display\n * Used for showing total costs across multiple API responses\n */\nexport function sumUsageHistory(usageHistory: ChatUsageDisplay[]): ChatUsageDisplay | undefined {\n  if (usageHistory.length === 0) return undefined;\n\n  // Track if any costs are undefined (model pricing unknown)\n  let hasUndefinedCosts = false;\n\n  const sum: ChatUsageDisplay = {\n    input: { tokens: 0, cost_usd: 0 },\n    cached: { tokens: 0, cost_usd: 0 },\n    cacheCreate: { tokens: 0, cost_usd: 0 },\n    output: { tokens: 0, cost_usd: 0 },\n    reasoning: { tokens: 0, cost_usd: 0 },\n  };\n\n  for (const usage of usageHistory) {\n    // Iterate over each component and sum tokens and costs\n    for (const key of Object.keys(sum) as Array<keyof ChatUsageDisplay>) {\n      sum[key].tokens += usage[key].tokens;\n      if (usage[key].cost_usd === undefined) {\n        hasUndefinedCosts = true;\n      } else {\n        sum[key].cost_usd = (sum[key].cost_usd ?? 0) + (usage[key].cost_usd ?? 0);\n      }\n    }\n  }\n\n  // If any costs were undefined, set all to undefined\n  if (hasUndefinedCosts) {\n    sum.input.cost_usd = undefined;\n    sum.cached.cost_usd = undefined;\n    sum.cacheCreate.cost_usd = undefined;\n    sum.output.cost_usd = undefined;\n    sum.reasoning.cost_usd = undefined;\n  }\n\n  return sum;\n}\n\n/**\n * Calculate token statistics from raw CmuxMessages\n * This is the single source of truth for token counting\n *\n * @param messages - Array of CmuxMessages from chat history\n * @param model - Model string (e.g., \"anthropic:claude-opus-4-1\")\n * @returns ChatStats with token breakdown by consumer and usage history\n */\nexport function calculateTokenStats(messages: CmuxMessage[], model: string): ChatStats {\n  if (messages.length === 0) {\n    return {\n      consumers: [],\n      totalTokens: 0,\n      model,\n      tokenizerName: \"No messages\",\n      usageHistory: [],\n    };\n  }\n\n  performance.mark(\"calculateTokenStatsStart\");\n\n  const tokenizer = getTokenizerForModel(model);\n  const consumerMap = new Map<string, { fixed: number; variable: number }>();\n  const toolsWithDefinitions = new Set<string>(); // Track which tools have definitions included\n  const usageHistory: ChatUsageDisplay[] = [];\n  let systemMessageTokens = 0; // Accumulate system message tokens across all requests\n\n  // Calculate tokens by content producer (User, Assistant, individual tools)\n  // This shows what activities are consuming tokens, useful for debugging costs\n  for (const message of messages) {\n    if (message.role === \"user\") {\n      // User message text\n      let userTokens = 0;\n      for (const part of message.parts) {\n        if (part.type === \"text\") {\n          userTokens += tokenizer.countTokens(part.text);\n        }\n      }\n\n      const existing = consumerMap.get(\"User\") ?? { fixed: 0, variable: 0 };\n      consumerMap.set(\"User\", { fixed: 0, variable: existing.variable + userTokens });\n    } else if (message.role === \"assistant\") {\n      // Accumulate system message tokens from this request\n      if (message.metadata?.systemMessageTokens) {\n        systemMessageTokens += message.metadata.systemMessageTokens;\n      }\n\n      // Store usage in history for comparison with estimates\n      if (message.metadata?.usage) {\n        const usage = createDisplayUsage(\n          message.metadata.usage,\n          message.metadata.model ?? model, // Use actual model from request, not UI model\n          message.metadata.providerMetadata\n        );\n        if (usage) {\n          usageHistory.push(usage);\n        }\n      }\n\n      // Count assistant text separately from tools\n      // IMPORTANT: Batch tokenization by type to avoid calling tokenizer for each tiny part\n      // (reasoning messages can have 600+ parts like \"I\", \"'m\", \" thinking\")\n\n      // Group and concatenate parts by type\n      const textParts = message.parts.filter((p) => p.type === \"text\");\n      const reasoningParts = message.parts.filter((p) => p.type === \"reasoning\");\n\n      // Tokenize text parts once (not per part!)\n      if (textParts.length > 0) {\n        const allText = textParts.map((p) => p.text).join(\"\");\n        const textTokens = tokenizer.countTokens(allText);\n        const existing = consumerMap.get(\"Assistant\") ?? { fixed: 0, variable: 0 };\n        consumerMap.set(\"Assistant\", { fixed: 0, variable: existing.variable + textTokens });\n      }\n\n      // Tokenize reasoning parts once (not per part!)\n      if (reasoningParts.length > 0) {\n        const allReasoning = reasoningParts.map((p) => p.text).join(\"\");\n        const reasoningTokens = tokenizer.countTokens(allReasoning);\n        const existing = consumerMap.get(\"Reasoning\") ?? { fixed: 0, variable: 0 };\n        consumerMap.set(\"Reasoning\", { fixed: 0, variable: existing.variable + reasoningTokens });\n      }\n\n      // Handle tool parts\n      for (const part of message.parts) {\n        if (part.type === \"dynamic-tool\") {\n          // Count tool arguments\n          const argsTokens = countTokensForData(part.input, tokenizer);\n\n          // Count tool results if available\n          // Tool results have nested structure: { type: \"json\", value: {...} }\n          let resultTokens = 0;\n          if (part.state === \"output-available\" && part.output) {\n            // Extract the actual data from the nested output structure\n            const outputData =\n              typeof part.output === \"object\" && part.output !== null && \"value\" in part.output\n                ? part.output.value\n                : part.output;\n\n            // Special handling for web_search encrypted content\n            if (part.toolName === \"web_search\" && Array.isArray(outputData)) {\n              // Check if this is encrypted web search results\n              const hasEncryptedContent = outputData.some(\n                (item: unknown): item is { encryptedContent: string } =>\n                  item !== null &&\n                  typeof item === \"object\" &&\n                  \"encryptedContent\" in item &&\n                  typeof (item as Record<string, unknown>).encryptedContent === \"string\"\n              );\n\n              if (hasEncryptedContent) {\n                // Calculate tokens for encrypted content with heuristic\n                // Encrypted content is base64 encoded and then encrypted/compressed\n                // Apply reduction factors:\n                // 1. Remove base64 overhead (multiply by 0.75)\n                // 2. Apply an estimated token reduction factor of 4\n                let encryptedChars = 0;\n                for (const item of outputData) {\n                  if (\n                    item !== null &&\n                    typeof item === \"object\" &&\n                    \"encryptedContent\" in item &&\n                    typeof (item as Record<string, unknown>).encryptedContent === \"string\"\n                  ) {\n                    encryptedChars += (item as { encryptedContent: string }).encryptedContent\n                      .length;\n                  }\n                }\n                // Use heuristic: encrypted chars / 40 for token estimation\n                resultTokens = Math.ceil(encryptedChars * 0.75);\n              } else {\n                // Normal web search results without encryption\n                resultTokens = countTokensForData(outputData, tokenizer);\n              }\n            } else {\n              // Normal tool results\n              resultTokens = countTokensForData(outputData, tokenizer);\n            }\n          }\n\n          // Get existing or create new consumer for this tool\n          const existing = consumerMap.get(part.toolName) ?? { fixed: 0, variable: 0 };\n\n          // Add tool definition tokens if this is the first time we see this tool\n          let fixedTokens = existing.fixed;\n          if (!toolsWithDefinitions.has(part.toolName)) {\n            fixedTokens += getToolDefinitionTokens(part.toolName, model);\n            toolsWithDefinitions.add(part.toolName);\n          }\n\n          // Add variable tokens (args + results)\n          const variableTokens = existing.variable + argsTokens + resultTokens;\n\n          consumerMap.set(part.toolName, { fixed: fixedTokens, variable: variableTokens });\n        }\n      }\n    }\n  }\n\n  // Add system message tokens as a consumer if present\n  if (systemMessageTokens > 0) {\n    consumerMap.set(\"System\", { fixed: 0, variable: systemMessageTokens });\n  }\n\n  // Calculate total tokens\n  const totalTokens = Array.from(consumerMap.values()).reduce(\n    (sum, val) => sum + val.fixed + val.variable,\n    0\n  );\n\n  // Create sorted consumer array (descending by token count)\n  const consumers: TokenConsumer[] = Array.from(consumerMap.entries())\n    .map(([name, counts]) => {\n      const total = counts.fixed + counts.variable;\n      return {\n        name,\n        tokens: total,\n        percentage: totalTokens > 0 ? (total / totalTokens) * 100 : 0,\n        fixedTokens: counts.fixed > 0 ? counts.fixed : undefined,\n        variableTokens: counts.variable > 0 ? counts.variable : undefined,\n      };\n    })\n    .sort((a, b) => b.tokens - a.tokens);\n\n  return {\n    consumers,\n    totalTokens,\n    model,\n    tokenizerName: tokenizer.name,\n    usageHistory,\n  };\n}\n"]}