{"version":3,"file":"toolPolicy.js","sourceRoot":"","sources":["../../../src/utils/tools/toolPolicy.ts"],"names":[],"mappings":";;AA8BA,0CAsEC;AAlFD;;;;;;;;;;;GAWG;AACH,SAAgB,eAAe,CAC7B,KAA2B,EAC3B,MAAmB;IAEnB,+CAA+C;IAC/C,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACnC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,sCAAsC;IACtC,MAAM,aAAa,GAAG,IAAI,GAAG,EAAU,CAAC;IACxC,KAAK,MAAM,MAAM,IAAI,MAAM,EAAE,CAAC;QAC5B,IAAI,MAAM,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;YAChC,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,IAAI,MAAM,CAAC,WAAW,GAAG,CAAC,CAAC;YACpD,KAAK,MAAM,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC1C,IAAI,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;oBACzB,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBAC9B,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,6CAA6C;IAC7C,IAAI,aAAa,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC;QAC3B,MAAM,IAAI,KAAK,CACb,yDAAyD,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,sCAAsC,CACpI,CAAC;IACJ,CAAC;IAED,+CAA+C;IAC/C,IAAI,aAAa,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;QAC7B,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;QAClD,OAAO;YACL,CAAC,YAAY,CAAC,EAAE,KAAK,CAAC,YAAY,CAAC;SACpC,CAAC;IACJ,CAAC;IAED,yDAAyD;IACzD,6CAA6C;IAC7C,MAAM,UAAU,GAAG,IAAI,GAAG,EAAmB,CAAC;IAE9C,kDAAkD;IAClD,KAAK,MAAM,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QAC1C,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IACjC,CAAC;IAED,iFAAiF;IACjF,KAAK,MAAM,MAAM,IAAI,MAAM,EAAE,CAAC;QAC5B,IAAI,MAAM,CAAC,MAAM,KAAK,SAAS;YAAE,SAAS;QAE1C,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,IAAI,MAAM,CAAC,WAAW,GAAG,CAAC,CAAC;QACpD,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,KAAK,QAAQ,CAAC;QAEhD,iCAAiC;QACjC,KAAK,MAAM,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;YAC1C,IAAI,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACzB,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;YACzC,CAAC;QACH,CAAC;IACH,CAAC;IAED,qCAAqC;IACrC,MAAM,aAAa,GAAyB,EAAE,CAAC;IAC/C,KAAK,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QACrD,IAAI,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,IAAI,EAAE,CAAC;YACtC,aAAa,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;QACjC,CAAC;IACH,CAAC;IAED,OAAO,aAAa,CAAC;AACvB,CAAC","sourcesContent":["import type { Tool } from \"ai\";\n\n/**\n * Filter for tool policy - determines if a tool should be enabled, disabled, or required\n */\nexport interface ToolPolicyFilter {\n  /** Regex pattern to match tool names (e.g., \"bash\", \"file_edit_.*\", \".*\") */\n  regex_match: string;\n  /** Action to take when pattern matches */\n  action: \"enable\" | \"disable\" | \"require\";\n}\n\n/**\n * Tool policy - array of filters applied in order\n * Default behavior is \"allow\" (all tools enabled) for backwards compatibility\n */\nexport type ToolPolicy = ToolPolicyFilter[];\n\n/**\n * Apply tool policy to filter available tools\n * @param tools All available tools\n * @param policy Optional policy to apply (default: allow all)\n * @returns Filtered tools based on policy\n *\n * Algorithm:\n * 1. Check if any tool is marked as \"require\"\n * 2. If a tool is required, disable all other tools (at most one can be required)\n * 3. Otherwise, start with default \"allow\" for all tools and apply filters in order\n * 4. Last matching filter wins\n */\nexport function applyToolPolicy(\n  tools: Record<string, Tool>,\n  policy?: ToolPolicy\n): Record<string, Tool> {\n  // No policy = allow all (backwards compatible)\n  if (!policy || policy.length === 0) {\n    return tools;\n  }\n\n  // First pass: find any required tools\n  const requiredTools = new Set<string>();\n  for (const filter of policy) {\n    if (filter.action === \"require\") {\n      const regex = new RegExp(`^${filter.regex_match}$`);\n      for (const toolName of Object.keys(tools)) {\n        if (regex.test(toolName)) {\n          requiredTools.add(toolName);\n        }\n      }\n    }\n  }\n\n  // Validate: at most one tool can be required\n  if (requiredTools.size > 1) {\n    throw new Error(\n      `Tool policy error: Multiple tools marked as required (${Array.from(requiredTools).join(\", \")}). At most one tool can be required.`\n    );\n  }\n\n  // If a tool is required, return only that tool\n  if (requiredTools.size === 1) {\n    const requiredTool = Array.from(requiredTools)[0];\n    return {\n      [requiredTool]: tools[requiredTool],\n    };\n  }\n\n  // No required tools: apply standard enable/disable logic\n  // Build a map of tool name -> enabled status\n  const toolStatus = new Map<string, boolean>();\n\n  // Initialize all tools as enabled (default allow)\n  for (const toolName of Object.keys(tools)) {\n    toolStatus.set(toolName, true);\n  }\n\n  // Apply each filter in order (skip \"require\" actions as they were handled above)\n  for (const filter of policy) {\n    if (filter.action === \"require\") continue;\n\n    const regex = new RegExp(`^${filter.regex_match}$`);\n    const shouldEnable = filter.action === \"enable\";\n\n    // Apply filter to matching tools\n    for (const toolName of Object.keys(tools)) {\n      if (regex.test(toolName)) {\n        toolStatus.set(toolName, shouldEnable);\n      }\n    }\n  }\n\n  // Filter tools based on final status\n  const filteredTools: Record<string, Tool> = {};\n  for (const [toolName, tool] of Object.entries(tools)) {\n    if (toolStatus.get(toolName) === true) {\n      filteredTools[toolName] = tool;\n    }\n  }\n\n  return filteredTools;\n}\n"]}