{"version":3,"file":"suggestions.js","sourceRoot":"","sources":["../../../src/utils/slashCommands/suggestions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Slash command suggestions generation\n */\n\nimport { getSlashCommandDefinitions } from \"./parser\";\nimport { SLASH_COMMAND_DEFINITION_MAP } from \"./registry\";\nimport type {\n  SlashCommandDefinition,\n  SlashSuggestion,\n  SlashSuggestionContext,\n  SuggestionDefinition,\n} from \"./types\";\n\nexport type { SlashSuggestion } from \"./types\";\n\nconst COMMAND_DEFINITIONS = getSlashCommandDefinitions();\n\nfunction filterAndMapSuggestions<T extends SuggestionDefinition>(\n  definitions: readonly T[],\n  partial: string,\n  build: (definition: T) => SlashSuggestion\n): SlashSuggestion[] {\n  const normalizedPartial = partial.trim().toLowerCase();\n\n  return definitions\n    .filter((definition) =>\n      normalizedPartial ? definition.key.toLowerCase().startsWith(normalizedPartial) : true\n    )\n    .map((definition) => build(definition));\n}\n\nfunction buildTopLevelSuggestions(partial: string): SlashSuggestion[] {\n  return filterAndMapSuggestions(COMMAND_DEFINITIONS, partial, (definition) => {\n    const appendSpace = definition.appendSpace ?? true;\n    const replacement = `/${definition.key}${appendSpace ? \" \" : \"\"}`;\n    return {\n      id: `command:${definition.key}`,\n      display: `/${definition.key}`,\n      description: definition.description,\n      replacement,\n    };\n  });\n}\n\nfunction buildSubcommandSuggestions(\n  commandDefinition: SlashCommandDefinition,\n  partial: string,\n  prefixTokens: string[]\n): SlashSuggestion[] {\n  const subcommands = commandDefinition.children ?? [];\n\n  return filterAndMapSuggestions(subcommands, partial, (definition) => {\n    const appendSpace = definition.appendSpace ?? true;\n    const replacementTokens = [...prefixTokens, definition.key];\n    const replacementBase = `/${replacementTokens.join(\" \")}`;\n    return {\n      id: `command:${replacementTokens.join(\":\")}`,\n      display: definition.key,\n      description: definition.description,\n      replacement: `${replacementBase}${appendSpace ? \" \" : \"\"}`,\n    };\n  });\n}\n\nexport function getSlashCommandSuggestions(\n  input: string,\n  context: SlashSuggestionContext = {}\n): SlashSuggestion[] {\n  if (!input.startsWith(\"/\")) {\n    return [];\n  }\n\n  const remainder = input.slice(1);\n  if (remainder.startsWith(\" \")) {\n    return [];\n  }\n\n  const parts = remainder.split(/\\s+/);\n  const tokens = parts.filter((part) => part.length > 0);\n  const hasTrailingSpace = remainder.endsWith(\" \") || remainder.length === 0;\n  const completedTokens = hasTrailingSpace ? tokens : tokens.slice(0, -1);\n  const partialToken = hasTrailingSpace ? \"\" : (tokens[tokens.length - 1] ?? \"\");\n  const stage = completedTokens.length;\n\n  if (stage === 0) {\n    return buildTopLevelSuggestions(partialToken);\n  }\n\n  const rootKey = completedTokens[0] ?? tokens[0];\n  if (!rootKey) {\n    return [];\n  }\n\n  const rootDefinition = SLASH_COMMAND_DEFINITION_MAP.get(rootKey);\n  if (!rootDefinition) {\n    return [];\n  }\n\n  const definitionPath: SlashCommandDefinition[] = [rootDefinition];\n  let lastDefinition = rootDefinition;\n\n  for (let i = 1; i < completedTokens.length; i++) {\n    const token = completedTokens[i];\n    const nextDefinition = (lastDefinition.children ?? []).find((child) => child.key === token);\n\n    if (!nextDefinition) {\n      break;\n    }\n\n    definitionPath.push(nextDefinition);\n    lastDefinition = nextDefinition;\n  }\n\n  const matchedDefinitionCount = definitionPath.length;\n\n  // Try custom suggestions handler from the last matched definition\n  if (lastDefinition.suggestions) {\n    const customSuggestions = lastDefinition.suggestions({\n      stage,\n      partialToken,\n      definitionPath,\n      completedTokens,\n      context,\n    });\n\n    if (customSuggestions !== null) {\n      return customSuggestions;\n    }\n  }\n\n  // Fall back to subcommand suggestions if available\n  if (stage <= matchedDefinitionCount) {\n    const definitionForSuggestions = definitionPath[Math.max(0, stage - 1)];\n\n    if (definitionForSuggestions && (definitionForSuggestions.children ?? []).length > 0) {\n      const prefixTokens = completedTokens.slice(0, stage);\n      return buildSubcommandSuggestions(definitionForSuggestions, partialToken, prefixTokens);\n    }\n  }\n\n  return [];\n}\n"]}