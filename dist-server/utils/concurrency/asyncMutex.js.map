{"version":3,"file":"asyncMutex.js","sourceRoot":"","sources":["../../../src/utils/concurrency/asyncMutex.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;GAaG;AACH,MAAa,UAAU;IACb,MAAM,GAAG,KAAK,CAAC;IACf,KAAK,GAAsB,EAAE,CAAC;IAEtC;;;OAGG;IACH,KAAK,CAAC,OAAO;QACX,wCAAwC;QACxC,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC;YACnB,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QACjE,CAAC;QAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,OAAO,IAAI,cAAc,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAED;;;OAGG;IACH,OAAO;QACL,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QAChC,IAAI,IAAI,EAAE,CAAC;YACT,IAAI,EAAE,CAAC,CAAC,sBAAsB;QAChC,CAAC;IACH,CAAC;CACF;AA7BD,gCA6BC;AAED;;;;;GAKG;AACH,MAAM,cAAc;IACW;IAA7B,YAA6B,KAAiB;QAAjB,UAAK,GAAL,KAAK,CAAY;IAAG,CAAC;IAElD;;OAEG;IACH,CAAC,MAAM,CAAC,YAAY,CAAC;QACnB,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;QACrB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;CACF","sourcesContent":["/**\n * AsyncMutex - A mutual exclusion lock for async operations\n *\n * Ensures only one async operation can hold the lock at a time.\n * Uses `using` declarations for guaranteed lock release.\n *\n * Example:\n * ```typescript\n * const mutex = new AsyncMutex();\n * await using lock = await mutex.acquire();\n * // Critical section - only one execution at a time\n * // Lock automatically released when scope exits\n * ```\n */\nexport class AsyncMutex {\n  private locked = false;\n  private queue: Array<() => void> = [];\n\n  /**\n   * Acquire the lock. Blocks until lock is available.\n   * Returns an AsyncDisposable lock that auto-releases on scope exit.\n   */\n  async acquire(): Promise<AsyncMutexLock> {\n    // Wait in queue until lock is available\n    while (this.locked) {\n      await new Promise<void>((resolve) => this.queue.push(resolve));\n    }\n\n    this.locked = true;\n    return new AsyncMutexLock(this);\n  }\n\n  /**\n   * Release the lock and wake up next waiter in queue\n   * @internal - Should only be called by AsyncMutexLock\n   */\n  release(): void {\n    this.locked = false;\n    const next = this.queue.shift();\n    if (next) {\n      next(); // Wake up next waiter\n    }\n  }\n}\n\n/**\n * AsyncMutexLock - Auto-releasing lock handle\n *\n * Implements AsyncDisposable to ensure lock is released when scope exits.\n * This provides static compile-time guarantees against lock leaks.\n */\nclass AsyncMutexLock implements AsyncDisposable {\n  constructor(private readonly mutex: AsyncMutex) {}\n\n  /**\n   * Release the lock when the `using` block exits\n   */\n  [Symbol.asyncDispose](): Promise<void> {\n    this.mutex.release();\n    return Promise.resolve();\n  }\n}\n"]}