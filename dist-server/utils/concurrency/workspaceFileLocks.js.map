{"version":3,"file":"workspaceFileLocks.js","sourceRoot":"","sources":["../../../src/utils/concurrency/workspaceFileLocks.ts"],"names":[],"mappings":";;;AAAA,yCAAsC;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AACU,QAAA,kBAAkB,GAAG,IAAI,mBAAQ,EAAU,CAAC","sourcesContent":["import { MutexMap } from \"./mutexMap\";\n\n/**\n * Shared file operation lock for all workspace-related file services.\n *\n * Why this exists:\n * Multiple services (HistoryService, PartialService) operate on files within\n * the same workspace directory. When these services call each other while holding\n * locks, separate mutex instances can cause deadlock:\n *\n * Deadlock scenario with separate locks:\n * 1. PartialService.commitToHistory() acquires partialService.fileLocks[workspace]\n * 2. Inside commitToHistory, calls historyService.updateHistory()\n * 3. historyService.updateHistory() tries to acquire historyService.fileLocks[workspace]\n * 4. If another operation holds historyService.fileLocks and tries to acquire\n *    partialService.fileLocks â†’ DEADLOCK\n *\n * Solution:\n * All workspace file services share this single MutexMap instance. This ensures:\n * - Only one file operation per workspace at a time across ALL services\n * - Nested calls within the same operation won't try to re-acquire the lock\n *   (MutexMap allows this by queuing operations)\n * - No deadlock from lock ordering issues\n *\n * Trade-off:\n * This is more conservative than separate locks (less concurrency) but guarantees\n * correctness. Since file operations are fast (ms range), the performance impact\n * is negligible compared to AI API calls (seconds range).\n */\nexport const workspaceFileLocks = new MutexMap<string>();\n"]}