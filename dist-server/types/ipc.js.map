{"version":3,"file":"ipc.js","sourceRoot":"","sources":["../../src/types/ipc.ts"],"names":[],"mappings":";;;AAiEA,8CAEC;AAGD,sCAEC;AAGD,0CAEC;AAGD,sCAEC;AAGD,sCAEC;AAGD,kCAEC;AAGD,sCAEC;AAGD,0CAEC;AAGD,0CAEC;AAGD,sCAEC;AAGD,4CAEC;AAGD,wCAEC;AAtGD,kEAAkE;AAClE,6DAAyE;AAGhE,6FAHA,4BAAY,OAGA;AAAE,+FAHA,8BAAc,OAGA;AAwCrC,oCAAoC;AACpC,SAAgB,iBAAiB,CAAC,GAAyB;IACzD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,CAAC;AACnD,CAAC;AAED,uCAAuC;AACvC,SAAgB,aAAa,CAAC,GAAyB;IACrD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,cAAc,CAAC;AACtD,CAAC;AAED,iCAAiC;AACjC,SAAgB,eAAe,CAAC,GAAyB;IACvD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,QAAQ,CAAC;AAChD,CAAC;AAED,qCAAqC;AACrC,SAAgB,aAAa,CAAC,GAAyB;IACrD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,cAAc,CAAC;AACtD,CAAC;AAED,qCAAqC;AACrC,SAAgB,aAAa,CAAC,GAAyB;IACrD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,cAAc,CAAC;AACtD,CAAC;AAED,mCAAmC;AACnC,SAAgB,WAAW,CAAC,GAAyB;IACnD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,YAAY,CAAC;AACpD,CAAC;AAED,qCAAqC;AACrC,SAAgB,aAAa,CAAC,GAAyB;IACrD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,cAAc,CAAC;AACtD,CAAC;AAED,wCAAwC;AACxC,SAAgB,eAAe,CAAC,GAAyB;IACvD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,iBAAiB,CAAC;AACzD,CAAC;AAED,wCAAwC;AACxC,SAAgB,eAAe,CAAC,GAAyB;IACvD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,iBAAiB,CAAC;AACzD,CAAC;AAED,sCAAsC;AACtC,SAAgB,aAAa,CAAC,GAAyB;IACrD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,eAAe,CAAC;AACvD,CAAC;AAED,wCAAwC;AACxC,SAAgB,gBAAgB,CAAC,GAAyB;IACxD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,iBAAiB,CAAC;AACzD,CAAC;AAED,sCAAsC;AACtC,SAAgB,cAAc,CAAC,GAAyB;IACtD,OAAO,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,eAAe,CAAC;AACvD,CAAC","sourcesContent":["import type { Result } from \"./result\";\nimport type { WorkspaceMetadata } from \"./workspace\";\nimport type { CmuxMessage } from \"./message\";\nimport type { ProjectConfig } from \"@/config\";\nimport type { SendMessageError, StreamErrorType } from \"./errors\";\nimport type { ThinkingLevel } from \"./thinking\";\nimport type { ToolPolicy } from \"@/utils/tools/toolPolicy\";\nimport type { BashToolResult } from \"./tools\";\nimport type {\n  StreamStartEvent,\n  StreamDeltaEvent,\n  StreamEndEvent,\n  StreamAbortEvent,\n  ToolCallStartEvent,\n  ToolCallDeltaEvent,\n  ToolCallEndEvent,\n  ReasoningDeltaEvent,\n  ReasoningEndEvent,\n} from \"./stream\";\n\n// Import constants from constants module (single source of truth)\nimport { IPC_CHANNELS, getChatChannel } from \"@/constants/ipc-constants\";\n\n// Re-export for TypeScript consumers\nexport { IPC_CHANNELS, getChatChannel };\n\n// Type for all channel names\nexport type IPCChannel = string;\n\n// Caught up message type\nexport interface CaughtUpMessage {\n  type: \"caught-up\";\n}\n\n// Stream error message type (for async streaming errors)\nexport interface StreamErrorMessage {\n  type: \"stream-error\";\n  messageId: string;\n  error: string;\n  errorType: StreamErrorType;\n}\n\n// Delete message type (for truncating history)\nexport interface DeleteMessage {\n  type: \"delete\";\n  historySequences: number[];\n}\n\n// Union type for workspace chat messages\nexport type WorkspaceChatMessage =\n  | CmuxMessage\n  | CaughtUpMessage\n  | StreamErrorMessage\n  | DeleteMessage\n  | StreamStartEvent\n  | StreamDeltaEvent\n  | StreamEndEvent\n  | StreamAbortEvent\n  | ToolCallStartEvent\n  | ToolCallDeltaEvent\n  | ToolCallEndEvent\n  | ReasoningDeltaEvent\n  | ReasoningEndEvent;\n\n// Type guard for caught up messages\nexport function isCaughtUpMessage(msg: WorkspaceChatMessage): msg is CaughtUpMessage {\n  return \"type\" in msg && msg.type === \"caught-up\";\n}\n\n// Type guard for stream error messages\nexport function isStreamError(msg: WorkspaceChatMessage): msg is StreamErrorMessage {\n  return \"type\" in msg && msg.type === \"stream-error\";\n}\n\n// Type guard for delete messages\nexport function isDeleteMessage(msg: WorkspaceChatMessage): msg is DeleteMessage {\n  return \"type\" in msg && msg.type === \"delete\";\n}\n\n// Type guard for stream start events\nexport function isStreamStart(msg: WorkspaceChatMessage): msg is StreamStartEvent {\n  return \"type\" in msg && msg.type === \"stream-start\";\n}\n\n// Type guard for stream delta events\nexport function isStreamDelta(msg: WorkspaceChatMessage): msg is StreamDeltaEvent {\n  return \"type\" in msg && msg.type === \"stream-delta\";\n}\n\n// Type guard for stream end events\nexport function isStreamEnd(msg: WorkspaceChatMessage): msg is StreamEndEvent {\n  return \"type\" in msg && msg.type === \"stream-end\";\n}\n\n// Type guard for stream abort events\nexport function isStreamAbort(msg: WorkspaceChatMessage): msg is StreamAbortEvent {\n  return \"type\" in msg && msg.type === \"stream-abort\";\n}\n\n// Type guard for tool call start events\nexport function isToolCallStart(msg: WorkspaceChatMessage): msg is ToolCallStartEvent {\n  return \"type\" in msg && msg.type === \"tool-call-start\";\n}\n\n// Type guard for tool call delta events\nexport function isToolCallDelta(msg: WorkspaceChatMessage): msg is ToolCallDeltaEvent {\n  return \"type\" in msg && msg.type === \"tool-call-delta\";\n}\n\n// Type guard for tool call end events\nexport function isToolCallEnd(msg: WorkspaceChatMessage): msg is ToolCallEndEvent {\n  return \"type\" in msg && msg.type === \"tool-call-end\";\n}\n\n// Type guard for reasoning delta events\nexport function isReasoningDelta(msg: WorkspaceChatMessage): msg is ReasoningDeltaEvent {\n  return \"type\" in msg && msg.type === \"reasoning-delta\";\n}\n\n// Type guard for reasoning end events\nexport function isReasoningEnd(msg: WorkspaceChatMessage): msg is ReasoningEndEvent {\n  return \"type\" in msg && msg.type === \"reasoning-end\";\n}\n\n// Options for sendMessage\nexport interface SendMessageOptions {\n  editMessageId?: string;\n  thinkingLevel?: ThinkingLevel;\n  model: string;\n  toolPolicy?: ToolPolicy;\n  additionalSystemInstructions?: string;\n  maxOutputTokens?: number;\n}\n\n// API method signatures (shared between main and preload)\n// We strive to have a small, tight interface between main and the renderer\n// to promote good SoC and testing.\nexport interface IPCApi {\n  config: {\n    load(): Promise<{ projects: Array<[string, ProjectConfig]> }>;\n    save(config: { projects: Array<[string, ProjectConfig]> }): Promise<boolean>;\n  };\n  dialog: {\n    selectDirectory(): Promise<string | null>;\n  };\n  providers: {\n    setProviderConfig(\n      provider: string,\n      keyPath: string[],\n      value: string\n    ): Promise<Result<void, string>>;\n    list(): Promise<string[]>;\n  };\n  workspace: {\n    list(): Promise<WorkspaceMetadata[]>;\n    create(\n      projectPath: string,\n      branchName: string\n    ): Promise<{ success: true; metadata: WorkspaceMetadata } | { success: false; error: string }>;\n    remove(workspaceId: string): Promise<{ success: boolean; error?: string }>;\n    rename(\n      workspaceId: string,\n      newName: string\n    ): Promise<Result<{ newWorkspaceId: string }, string>>;\n    sendMessage(\n      workspaceId: string,\n      message: string,\n      options?: SendMessageOptions\n    ): Promise<Result<void, SendMessageError>>;\n    truncateHistory(workspaceId: string, percentage?: number): Promise<Result<void, string>>;\n    replaceChatHistory(\n      workspaceId: string,\n      summaryMessage: CmuxMessage\n    ): Promise<Result<void, string>>;\n    getInfo(workspaceId: string): Promise<WorkspaceMetadata | null>;\n    executeBash(\n      workspaceId: string,\n      script: string,\n      options?: { timeout_secs?: number; max_lines?: number; stdin?: string }\n    ): Promise<Result<BashToolResult, string>>;\n    openTerminal(workspacePath: string): Promise<void>;\n\n    // Event subscriptions (renderer-only)\n    // These methods are designed to send current state immediately upon subscription,\n    // followed by real-time updates. We deliberately don't provide one-off getters\n    // to encourage the renderer to maintain an always up-to-date view of the state\n    // through continuous subscriptions rather than polling patterns.\n    onChat(workspaceId: string, callback: (data: WorkspaceChatMessage) => void): () => void;\n    onMetadata(\n      callback: (data: { workspaceId: string; metadata: WorkspaceMetadata }) => void\n    ): () => void;\n  };\n}\n"]}