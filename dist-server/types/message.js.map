{"version":3,"file":"message.js","sourceRoot":"","sources":["../../src/types/message.ts"],"names":[],"mappings":";;AA2HA,8CA0BC;AA3BD,yCAAyC;AACzC,SAAgB,iBAAiB,CAC/B,EAAU,EACV,IAA0B,EAC1B,OAAe,EACf,QAAuB,EACvB,eAAsC;IAEtC,MAAM,QAAQ,GAAG,OAAO;QACtB,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,MAAe,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,MAAe,EAAE,CAAC;QACpE,CAAC,CAAC,EAAE,CAAC;IACP,MAAM,KAAK,GAAG,CAAC,GAAG,QAAQ,EAAE,GAAG,CAAC,eAAe,IAAI,EAAE,CAAC,CAAC,CAAC;IAExD,qEAAqE;IACrE,0EAA0E;IAC1E,IAAI,IAAI,KAAK,MAAM,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC1C,MAAM,IAAI,KAAK,CACb,uFAAuF,CACxF,CAAC;IACJ,CAAC;IAED,OAAO;QACL,EAAE;QACF,IAAI;QACJ,QAAQ;QACR,KAAK;KACN,CAAC;AACJ,CAAC","sourcesContent":["import type { UIMessage } from \"ai\";\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\nimport type { StreamErrorType } from \"./errors\";\nimport type { ToolPolicy } from \"@/utils/tools/toolPolicy\";\n\n// Our custom metadata type\nexport interface CmuxMetadata {\n  historySequence?: number; // Assigned by backend for global message ordering (required when writing to history)\n  duration?: number;\n  timestamp?: number;\n  model?: string;\n  usage?: LanguageModelV2Usage; // AI SDK normalized usage (verbatim from streamResult.usage)\n  providerMetadata?: Record<string, unknown>; // Raw AI SDK provider data\n  systemMessageTokens?: number; // Token count for system message sent with this request (calculated by AIService)\n  partial?: boolean; // Whether this message was interrupted and is incomplete\n  synthetic?: boolean; // Whether this message was synthetically generated (e.g., [INTERRUPTED] sentinel)\n  error?: string; // Error message if stream failed\n  errorType?: StreamErrorType; // Error type/category if stream failed\n  compacted?: boolean; // Whether this message is a compacted summary of previous history\n  toolPolicy?: ToolPolicy; // Tool policy active when this message was sent (user messages only)\n}\n\n// Extended tool part type that supports interrupted tool calls (input-available state)\n// Standard AI SDK ToolUIPart only supports output-available (completed tools)\nexport interface CmuxToolPart {\n  type: \"dynamic-tool\";\n  toolCallId: string;\n  toolName: string;\n  state: \"input-available\" | \"output-available\";\n  input: unknown;\n  output?: unknown;\n}\n\n// Text part type\nexport interface CmuxTextPart {\n  type: \"text\";\n  text: string;\n}\n\n// Reasoning part type for extended thinking content\nexport interface CmuxReasoningPart {\n  type: \"reasoning\";\n  text: string;\n}\n\n// CmuxMessage extends UIMessage with our metadata and custom parts\n// Supports text, reasoning, and tool parts (including interrupted tool calls)\nexport type CmuxMessage = Omit<UIMessage<CmuxMetadata, never, never>, \"parts\"> & {\n  parts: Array<CmuxTextPart | CmuxReasoningPart | CmuxToolPart>;\n};\n\n// DisplayedMessage represents a single UI message block\n// This is what the UI components consume, splitting complex messages into separate visual blocks\nexport type DisplayedMessage =\n  | {\n      type: \"user\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original CmuxMessage ID for history operations\n      content: string;\n      historySequence: number; // Global ordering across all messages\n      timestamp?: number;\n    }\n  | {\n      type: \"assistant\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original CmuxMessage ID for history operations\n      content: string;\n      historySequence: number; // Global ordering across all messages\n      streamSequence?: number; // Local ordering within this assistant message\n      isStreaming: boolean;\n      isPartial: boolean; // Whether this message was interrupted\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\n      isCompacted: boolean; // Whether this is a compacted summary\n      model?: string;\n      timestamp?: number;\n      tokens?: number;\n    }\n  | {\n      type: \"tool\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original CmuxMessage ID for history operations\n      toolCallId: string;\n      toolName: string;\n      args: unknown;\n      result?: unknown;\n      status: \"pending\" | \"executing\" | \"completed\" | \"failed\" | \"interrupted\";\n      isPartial: boolean; // Whether the parent message was interrupted\n      historySequence: number; // Global ordering across all messages\n      streamSequence?: number; // Local ordering within this assistant message\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\n      timestamp?: number;\n    }\n  | {\n      type: \"reasoning\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original CmuxMessage ID for history operations\n      content: string;\n      historySequence: number; // Global ordering across all messages\n      streamSequence?: number; // Local ordering within this assistant message\n      isStreaming: boolean;\n      isPartial: boolean; // Whether the parent message was interrupted\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\n      timestamp?: number;\n      tokens?: number; // Reasoning tokens if available\n    }\n  | {\n      type: \"stream-error\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original CmuxMessage ID for history operations\n      error: string; // Error message\n      errorType: StreamErrorType; // Error type/category\n      historySequence: number; // Global ordering across all messages\n      timestamp?: number;\n      model?: string;\n    }\n  | {\n      type: \"history-hidden\";\n      id: string; // Display ID for UI/React keys\n      hiddenCount: number; // Number of messages hidden\n      historySequence: number; // Global ordering across all messages\n    };\n\n// Helper to create a simple text message\nexport function createCmuxMessage(\n  id: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n  metadata?: CmuxMetadata,\n  additionalParts?: CmuxMessage[\"parts\"]\n): CmuxMessage {\n  const textPart = content\n    ? [{ type: \"text\" as const, text: content, state: \"done\" as const }]\n    : [];\n  const parts = [...textPart, ...(additionalParts ?? [])];\n\n  // Validation: User messages must have at least one part with content\n  // This prevents empty user messages from being created (defense-in-depth)\n  if (role === \"user\" && parts.length === 0) {\n    throw new Error(\n      \"Cannot create user message with no parts. Empty messages should be rejected upstream.\"\n    );\n  }\n\n  return {\n    id,\n    role,\n    metadata,\n    parts,\n  };\n}\n"]}